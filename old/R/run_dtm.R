## ********************************************************************
## main routine for the Dynamic TOPMODEL for the areal groupings identified by a catchment analysis
## see Beven and Freer (2001), Metcalfe et al. (2015) for a description of the model
## *********************************************
## Notes on units:
## lengths are in m and times in hrs, coverted if necessary
## rainfall and pe in m/hr (will be converted from mm/hr as usual convention)
## storage in rain equivalent units e.g. m
## base flows expressed as specific fluxes per plan area: m^3/hr per m^2
## input flows expressed as total flux (m^3/hr)
## ****************************************************************************************************************
## Summary of model parameters
## ----------------------------------------------------------------------------------------------------------------
## Parameter                                         Units         Typical values (see Beven and Freer, 2001 (1), Beven 1997, Page et al 2006 (2))                                                                  Lower             Upper
## ----------------------------------------------------------------------------------------------------------------
## m     :   form of exponential decline in          m             0.005             0.025
##           conductivity
## sdmax:    max root zone storage                   m             0.005 (2)         0.2 (2)
## srz0:   initial root zone storage               -             0                 0.3
## ln_to  :   lateral saturated transmissivity        m^2/hr-1      -7 (2)            8
## sd_max  :   max effective deficit of saturated zone m             0.1               0.8
## td    :   unsaturated zone time delay             hr/m          0.1 (1, 2)        40 (2)
## ****************************************************************************************************************
#' Run Dynamic TOPMODEL against hydrometric data and a catchment discretisation
#' @export
#' @details The grouping (HRU) table may be generated by the discretise method and includes each indexed channel as separate group. See Metcalfe et al. (2015) for descriptions of the parameters maintained in this table.
#' @details Evapotranspiration input can be generated using the approx.pe.ts method
#' @param groups Data frame of areal group definitions along with their hydrological parameters (see Metcalfe et al., 2015)
#' @param weights If the discretisation has n groups, this holds the n x n flux distribution (weighting) matrix defining downslope
#' @param rain A time series of rainfall data in m/hr. One column per gauge if multiple gauges used.
#' @param routing data.frame  Channel routing table comprises a two-column data.frame or matrix. Its first column should be average flow distance to the outlet in m, the second the proportions of the catchment channel network within each distance category. Can be generated by make.routing.table
#' @param qobs Optional time series of observation data
#' @param qt0 Initial specific discharge (m/hr)
#' @param pe Time series of potential evapotranspiration, at the same time step as rainfall data
#' @param dt Time step (hours). Defaults to the interval used by the rainfall data
# #' @param vchan Not used
# #' @param vof Not used
#' @param ichan Integer index of the "channel" group. Defaults to 1
#' @param i.out For multi-channel systems, the index of the outlet reach
#' @param sim.start Optional start time for simulation in any format that can be coerced into a POSIXct instance. Defaults to start of rainfall data
#' @param sim.end Optional end time of simulation in any format that can be coerced into a POSIXct instance. Defaults to end of rainfall data
# #' @param text.out location to print the text output
# #' @param disp.par List of graphical routing parameters. A set of defaults are retrieved by calling disp.par()
#' @param ntt Number of inner time steps used in subsurface routing algorithm
# #' @param dqds Function to supply a custom flux-storage relationship as the kinematic wave celerity. If not supplied then exponential relationship used.
#' @param upstream_inputs xts A list of any upstream hydrographs in addition to hillslope runoff feeding into the river network
#' @param Wsurf matrix  Surface routing matrix. Defines routing of overland flow downslope between units. By default identical to subsurface routing matrix by default, but can be altered to reflect modified connectivity of certain areas with the hillslope
#' @param monitor Level of output to provide to help monitor run
#' @param use_cpp Use Rcpp versions of functions where possible
#' @return qsim: time series of specific discharges (m/hr) at the specified time interval. can be converted to absolute discharges by multiplying by catch.area
#' @return catch.area: the catchment area in m^2, calculated from the areas in the groups table
#' @return data.in: a list comprising the parameters supplied to the call
#' @return datetime sim.start Start of simulation
#' @return sim.end  datetime   End time of simulation
#' @return fluxes: a list comprising, for each response unit the specific base flows qbf, specific upslope inputs qin, drainage fluxes quz, and any overland flow qof, all in m/hr
#' @return storages: a list comprising, for each response unit, root zone and unsaturated storage, total storage deficit and surface storages (all m)
#' @note If rain, pe or observation data differ in time period, use aggregate_xts to coerce the relevant series to the desired  time interval
# #' @seealso aggregate_xts
# #' @seealso discretise
#' @references Metcalfe, P., Beven, K., & Freer, J. (2015). Dynamic TOPMODEL: a new implementation in R and its sensitivity to time and space steps. Environmental Modelling & Software, 72, 155-172.
#' @examples
#'\dontrun{
#' require(dynatop)
#' data(brompton)
#'
#' # Examine the November 2012 event that flooded the village (see Metcalfe et al., 2017)
#' sel <- "2012-11-23 12:00::2012-12-01"
#' # Precalculated discretisation
#' disc <- brompton$disc
#' groups <- disc$groups
#' rain <- brompton$rain[sel]
#' # to 15 minute intervals
#' rain <- disaggregate_xts(rain, dt = 15/60)
#' # Reduce PE, seems a bit on high side and resulted in a weighting factor for the rainfall
#' pe <- brompton$pe[sel]/2
#' qobs <- brompton$qobs[sel]
#'
#' # Here we apply the same parameter values to all groups.
#' # we could also consider a discontinuity at the depth of subsurface drains (~1m)
#' # or in areas more remote from the channel that do not contribute fast subsurface
#' # flow via field drainage
#' groups <- disc$groups
#' groups$m <- 0.0051
#' # Simulate impermeable clay soils
#' groups$td <-  29
#' groups$ln_t0 <- 8.1
#' groups$srz_max <- 0.1
#' # initial root zone storage - almost full due to previous event
#' groups$srz0 <- 0.98
#' # Quite slow channel flow, which might be expected with the shallow and reedy
#' # low bedslope reaches with very rough banks comprising the major channel
#' groups$vchan <- 500
#' # Rain is supplied at hourly intervals: convert to 15 minutes
#' rain <- disaggregate_xts(rain, dt = 15/60)
#' weights <- disc$weights
#' # Output goes to a new window
#' graphics.off()
#' x11()
#'
#' # Initial discharge from the observations
#' qt0 <- as.numeric(qobs[1,])
#'
#' # Run the model across the November 2012 storm event
#' # using a 15 minute interval
#' run <- run_dtm(groups=groups,
#'                weights=weights,
#'                rain=rain,
#'                pe=pe,
#'                qobs=qobs,
#'                qt0=qt0,
#'                routing=brompton$routing,
#'                graphics.show=TRUE, max.q=2.4)
#' }
#'
run_dtm <- function(groups,
                    weights,
                    rain,
                    routing,
                    upstream_inputs=NULL,
                    qobs=NULL,
                    qt0=1e-4,
                    pe=NULL,
                    dt=NULL,
                    ntt=2,
                    ichan=1,
                    Wsurf=weights,  # surface flow matrix
                    i.out=ichan[1],
                    sim.start=NA,
                    sim.end=NA,
                    monitor=c("none","text"),
                    use_cpp=FALSE
                    ){
    FLOW_NAMES =c("qin", "qbf", "uz", "qof", "rain", "ae");
    STORE_NAMES = c("sd", "srz", "suz", "ex")

    monitor <- match.arg(monitor)
        
    start.time <- Sys.time()

    ## inner time step
    dtt <- dt/ntt

    ## setup input variable for run using supplied data, and copy the updated values back to
    ## to the current environment
    
    stores <- flows <- NA # bodge to stop error on package build
    data.in <- init_input(groups, dt, ntt,
                          weights, rain, pe, routing,
                          ichan=ichan,
                          i.out=i.out, qobs=qobs,
                          qt0=qt0,
                          FLOW_NAMES = FLOW_NAMES,
                          STORE_NAMES=STORE_NAMES,
                          sim.start=sim.start,
                          sim.end=sim.end,
                          calling.env=environment())
        
    ## add in any hydrographs from upstream
    upstream_inputs <- init_upstream_inputs(upstream_inputs, groups, dt=dt)

    ngroup <- nrow(groups)


    W <- weights
    catch.area <- sum(groups$area)
    ngroup <- nrow(groups)

    ## split rain and pe between gauges
    rain.dist <- as.matrix(rain[,pmin(groups$gauge.id, ncol(rain))]  )
    pe.dist <-   as.matrix(pe[,pmin(groups$gauge.id, ncol(rain))]  )

    ## apply any rain, overland flow or evapotranspiration multipliers for each of the HRU
    pe.dist <- t(apply(pe.dist, MARGIN=1, function(x)x*groups$pe_fact))
    rain.dist <- t(apply(rain.dist, MARGIN=1, function(x)x*groups$rain_fact))

    ## empty times series for storage within the channel unit
    chan.storage <- pe-pe
    bal <- chan.storage

    ## total overland flow contribution to channels
    Qof <- Qr[,ichan]

    max_it <- nrow(rain)
    tms <- index(rain)

    ## ensure any times with non-zero rainfall have no evapotranspiration
    pe.dist = pe.dist*(rain.dist==0)

    ## set a dummy value
    groups$srz_max[ichan] = 1;

    Qriv = rep(0, length(ichan));

    ## entire series
    rain.input = rain;

    ## much faster to refer to system states as individual vectors rather than elements of a list - actually isssue is they are a data.frame - list would be quick
    #print(is.data.frame(flows))
    #print(is.data.frame(stores))

    qbf = flows$qbf;
    qin= flows$qin;
    ex=stores$ex;
    sd=stores$sd;
    suz=stores$suz;
    qof = flows$qof;
    cw=groups$cw;
    vof=groups$vof;
    area=groups$area;
    ex_max=groups$ex_max;
    rain=flows$rain;
    ae=flows$ae;
    srz=stores$srz;
    m=groups$m;
    sd_max=groups$sd_max;
    srz_max=groups$srz_max;
    td=groups$td;
    uz=flows$uz;
    qbf_max=groups$qbf_max;

    ## the general solution to this system at time t is
    ## S = c1*exp(l1*t)u + c2*exp(l2*t*u)+...
    ## where u are the eigen vectors of WV, l1, l2... the corresponding eigen values
    ## and c1, c2... constants to be determined from boundary conditions

    ## identity matrix
    I = diag(nrow=ngroup);

    ## Qin = exS %*% Wsurf
    ## Linear storage-discharge relationship
    ## Qout = a * vof * ex
    ## dExS/dt = Qin - Qbf
    ##        = Wv %*% exS
    ## ExS is total surface excess storage
    ## where Wv = complementary overland routing matrix
    vof[ichan]=0;
    WV = t(diag(vof) %*% (Wsurf - I))
    ## (t(Wsurf) - I) %*% diag(vof)
    ## Solution for surface routing by Eigenvalue method (see Dummit, 2016; )
    ## general soln at time t is
    ## sigma(exp(lambda_i * t*)ci * ui)
    ## where ui are eigenvectors, li eigenvalues and ci constants TBD by
    ## boundary conditions
    eig = eigen(WV)
    ## Eigenmatrix and values
    U = eig$vectors
    lambda = eig$values
    ## inverse of Eigenmatrix
    Um1 = solve(U);

    ## complementary subsurface routing matrix
    Wdash <-
        as.matrix(
            diag(1/area, ngroup, ngroup) %*% t(W) %*% diag(area, ngroup, ngroup)
            - diag(ngroup)
        );

    message("Running Dynamic TOPMODEL using ", ngroup, " units")


    ## main loop
    for(it in 1:max_it){
  	tm <- tms[it]

  	## distribute any surface storage downslope for next time step
  	if(any(ex[] > 0)){
            ## Eigen value solution can return complex values if eigen values of WV are complex
            ## Solution will be real, however, so imaginary parts will  be nil
            ex = route_ex_eigen(ex, area, U, Um1, lambda, dt)

            ##  gain in overland flow from upslope
            ## This doesn't make the above ex calculation 
            ## qof <- funcpp_qin_surf(ex, ex_max, Wsurf, Wover, area, cw, vof)
  	}

        ## inputs from distributed storage assuming linear relationship between specific
  	## discharge and surface storage
        ##	qof <- stores$ex*groups$vof / a

  	## Allocate rainfall to groups using specified gauge specified, adding any
  	## overland flow from distributed from step. This allows for "run on"
        rain <-  rain.dist[it,] #+ qof

        stores0 <- stores

        Qriv[] <- 0

        ## initial storage
        s0 <- area*(srz + suz + ex-sd);

        ## how many time delay routing histograms were supplied
        nout = ncol(routing);

        ## max numer of time step shifts when routing
        n_shift = nrow(routing);

        ## inner loop to update flows and storages
        for(inner in 1:ntt){
            ## apply rain input and evapotranspiration (*rates*) across the inner time step
            ## note that rain and actual evap are maintained in flows
            ## updated <- root.zone(groups, flows, stores,
            ##                      pe=pe.dist[it,],
            ##                      dt=dtt, ichan)

            isat = sd <= 0;
            k = pe.dist[it,]/srz_max;

            ## Actual evap at this time steo
            ae =  k*srz;

            ## analytical solution to root zone storage
            srz = srz*exp(-dtt*k) + rain*dtt;

            ## amount of precipitation excess generating overland flow or recharging unsaturated zonew
            pex = pmax(srz- srz_max, 0);

            ## this is being lost
            srz = srz - pex;

            ## excess over saturation  routed onto surface, at this time step
            exi = pex*isat;
            ex = ex + exi;

            ## remove surface excess from unsaturated zone drainage
            pex = pex - exi;

            ## pex is excess drainage (rate) from root zone (over time step): add to unsat storage suz
            suz <- suz + pex;

            ## recharge rate through unsaturated drainage into saturated zone
            if(use_cpp){
                uz <- funcpp_uz(suz, sd, td, dtt)
            }else{
                uz <- funR_uz(suz, sd, td, dtt)
            }
            
            ## uz <- funcpp_uz(suz, sd, td, dtt)
            
            ## reduce storage by drainage out of zone over time step - limited in above call
            suz <- suz-uz*dtt;

            ## Distribute baseflows downslope through areas using precalculated inter-group
            ## solution of ODE system. Uses the Livermore solver lsosa
            ## identify any units that have dried out andare not producing any base flow

            flows[ichan,] <- 0
            qbf[ichan] = 0;

            ## nstep is the number of results to produce
            if(use_cpp){
                fun_dqdt <- funcpp_dqdt
            }else{
                fun_dqdt <- funR_dqdt
            }
            res <- deSolve::ode(y=qbf,
                       times=seq(0, dtt, length.out=2),
                       func=fun_dqdt,
                       parms=list(Wdash=Wdash,
                                  m=m,
                                  qbf_max=qbf_max,
                                  uz=uz))

            qbf = res[-1,-1]
            ## final row gives baseflows at the end stage
            ##  qbf <- res[2, iqbf+1]
            ##   ex = res[2, iex+1]

            ## throttling downslope flow to maximum at saturation
            ##   qbf <- pmin(qbf, qbf_max)

            ## distributing subsurface flows downslope - total inputs
            Qin <- vect_matrix_mult_cpp(qbf*area, W);

            ## converting to  specific input
            qin = Qin/area;

            ## excess over capacity generates return flow
            ## rate of generation of return flow is excess over maximum of net filling of area
            ret_fl <- pmax(qin-qbf-qbf_max, 0)

            ## remove it from the net input as has appeared on the surface!
            qin <- qin - ret_fl

            ## excess surface storage is generated in this time step.
            ex <- ex + ret_fl*dtt

            ## +ve = net drainage; -ve net filling
            ## qdrain <-

            ## update storage deficits with the new input and output flows
            ## deficit reduced by upslope input and unsat drainage and
            ## increased by downslope flow in to other units
            ## existing excess storage is removed from deficit
            sd_add <- (qbf-qin - uz) * dtt

            ## deficit in channel doesn't mean anything
            sd_add[ichan] <- 0

            ## update deficits
            sd <- sd + sd_add;

            ## -ve SD = excess surface storage
            sat.ex <- pmin(sd, 0)
            ex <- ex - sat.ex #    # + flows$ex*dtt

            ## defict always >= 0
            sd <- pmax(sd, 0)

            ## total flux transferred into river plus rainfall minus evap
            Qriv <- Qriv + (Qin[ichan] + (rain[ichan]-ae[ichan]) * area[ichan])/ntt
        }

        ## total input
        Qin[ichan] <- Qriv

        ## water balance: new storage
        s1 <- area*(srz + suz + ex-sd)
        input <- area * (rain -  ae)
        ## is new storage equal to old plus effectived rainfall? Ignore channel, but direct precipitation is considered
        bal[it,] <- (sum(s1[-ichan]) - (sum(s0[-ichan]) + sum(input[-ichan]*dt)))/sum(area[-ichan])

        ## additional overland input to channel across this time step, converted to a flow rate
        ## note +ve as long as distribution matrix only directs channel flow to the channel
        Qof[it,] = ex[ichan]/dt * area[ichan];

        ## Overland flow into channel gets routed to outlet immediately so remove
        ex[ichan] = 0;

        ## specific overland flow
        ## assumming linear relationship between discharge and storage
        ##   flows$qof <- stores$ex*groups$vof

        ## add input from overland flow to total channel inputs
        Qin[ichan] <- Qin[ichan] + Qof[it,]

        ## time shifted flows
        ##   q_shift = routing * Qin[ichan];

        ## route to outlet
        Qr[it:(it+n_shift-1),1:nout] = Qr[it:(it+n_shift-1),1:nout] + routing * Qin[ichan];

        ## ## route to outlet and update current
        ## Qr <- route_channel_flows(Qin=Qin,
        ##                           qbf=qbf,
        ##                           delays=routing,
        ##                           chan.store=chan.storage,
        ##                           w=w,
        ##                           area=area,
        ##                           Qr=Qr, it=it,
        ##                           dt=dt,
        ##                           ichan=ichan)

        for(upstream_input in upstream_inputs){
            ## add in any time-shifted hydrographs from gauge upstream of the catchment
            Qr[it,] <- Qr[it,] + as.numeric(upstream_input$qshift[it,])
            ## note that routing is to catchment outlet, not merely to point where input joins
            ## river network
        }

        fluxes[it,,2] <- qbf;
        fluxes[it,,1] <- qin;
        fluxes[it,,3] <- uz;
        ## fluxes[it,,4] <- qof; # removed since no longer calulated
        fluxes[it,,5] <- rain;
        fluxes[it,,6] <- ae;


        ## Flows between HRUs and drainage
        ## fluxes[it,,]<- as.matrix(flows[, FLOW_NAMES])


        ## SUmmarise storages
        storages[it,,1] <- sd;
        storages[it,,2] <- srz;
        storages[it,,3] <- suz;
        storages[it,,4] <- ex;

        ## overall actual evap
        evap[it,"ae"] <- weighted.mean(ae, area)

        ##cat(format(tm, fmt), "\t", signif(Qr[it,]/catch.area*1000,2), file=text.out, "\n");   #

        ## if(graphics.show){

        ##     ## chan.storage <- as.numeric(chan.storage-Qr[it,]+sum(flows$qin[ichan]))
        ##     ## chan.storages[it,] <- chan.storage
        ##     ## discharges, rain and ae in mm/hr
        ##     disp.results(it,
        ##                  tm=tm,
        ##                  qr=Qr*1000/catch.area,
        ##                  rain=rain.input*1000,
        ##                  evap=evap*1000,
        ##                  groups=groups,
        ##                  flows=flows,
        ##                  stores=stores,
        ##                  qobs=qobs*1000,
        ##                  ichan=ichan,
        ##                  text.out=text.out,
        ##                  log.msg="",
        ##                  start = sim.start,
        ##                  end = sim.end,
        ##                  disp.par=disp.par)

        ## }

    } # next iteration

    ## collecting the results together
    ## convert fluxes to a named list of time series
    fluxes <- apply(fluxes, MARGIN=3, function(x){list(x)})
    fluxes <- lapply(fluxes, function(x)xts(x[[1]], order.by=tms))

    ## calculating overland flow within each unit (specific per unit contour)
    ## qof = storages$ex * groups$vof

    ## specific discharge (in m/hr)
    qr=Qr/catch.area;

    names(fluxes) <- FLOW_NAMES;

    ## total ovf is amount transferred to outlet (includes rain directly to channel?)
    ## in this formulation all excess flow is routed immediately and then removed
    ## ovf <-   dt*sum(Qof)/catch.area
    mass.out <- sum(Qr*dt)

    ## converting storages to a list
    storages <- apply(storages, MARGIN=3, function(x){list(x)})
    storages <- lapply(storages, function(x)xts(x[[1]], order.by=tms))
    names(storages) <- STORE_NAMES;

    ## water balance checks
    ## output discharge
    Q_out <- sum(Qr*dt)
    tot_in <- sum(rain*catch.area)*dt
    ## total of absolute output from catchment
    tot_out <- Q_out+ sum(evap[,"ae"])*catch.area*dt
    ## storage gained (subtract deficit gained )
    sd.gain <- (as.numeric(storages$srz[it,-ichan])-as.numeric(storages$srz[1,-ichan]))*area[-1]

    sd.gain <- sd.gain - (as.numeric(storages$sd[it,-ichan])-as.numeric(storages$sd[1,-ichan]))*area[-1]

    run_time_secs = as.numeric(round(difftime(Sys.time(), start.time, units = "s"), 1));
    ttp=time_at_peak(qr);
    eff = NSE(qr, qobs);
    ## average time per model step and run time per unit simulation time
    step_time = run_time_secs/it;

    if(monitor=="text"){
        message("Time at peak is ", ttp)
        if(!is.null(qobs))message("NSE is ", eff)
        ## total overland flow into  channel (doesn't matter where it ends up after that)            ]
        message("Total overland flow contribution is ", round(sum(Qof)/catch.area*1000), " mm/hr")
        message("Total discharge was ", round(sum(Qr[])/catch.area*1000), " mm/hr")
        message("Run time was ", run_time_secs, " seconds")
        ## report average time per model step and run time per unit simulation time
        message("Run time per step was ", round(step_time, 3), " seconds");
    }

    ## results include original input data
    return(list("qsim"=qr,  # specific discharge
                "Qsim"=Qr,   # absolute discharge total
                "groups"=groups,
                "routing"=routing,
                "fluxes"=fluxes,
                "storages"=storages,
                eff=eff,
                ttp=ttp,
                run_time_secs=run_time_secs,
                "weights"=weights,  # the flux distributiom matrix
                "dt"=dt,
                "qobs"=qobs,
                "ae"=evap[,"ae"],
                "Qof"=Qof,
                "prop_ovf"=sum(Qof)/sum(Qr),   # proportion of discharge due to saturated overland flow
                "groups"=groups,
                "rain"=rain,
                "bal"=bal,
                catch.area=catch.area))
}






