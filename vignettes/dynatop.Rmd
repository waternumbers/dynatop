---
title: "Using Dynamic TOPMODEL"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using Dynamic TOPMODEL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
The purpose of this vignette is to provide an outline of the steps needed to
perform a Dynamic TOPMODEL simulation and introduce the formats of the data
input and returned. 

The data used in this example comes from Swindale and is contained within the package and can be loaded with
```{r, setup}
library(dynatop)
data("Swindale")
```
which returns the following variables
```{r data_loaded}
ls()
```
In the following
# The model structure
A dynamic TOPMODEL is described in a list object. The list has the following
elements
```{r model_parts}
names(model)
```
which are described in [associated
vignette](https://waternumbers.github.io/dynatop/articles/The_Model_Object.html). The
[dynatopGIS](https://waternumbers.github.io/dynatopGIS) package
can be used for constructing models. 

## Checking the model
The structure of the model can be tested:
```{r, test_model, error=TRUE, purl=FALSE}
check_model(model,delta=0)
```
In this case we can see that the model fails due to 
the redistribution of the flows from the hill slope HRUs. In all cases the sum of the fractions
describing the destination of the flows is greater then 1, meaning that flow
is artificially generated during the redistribution. This can be checked
manually by
```{r check_redistribution}
max( colSums(model$Fsz) - 1 )
max( colSums(model$Fsf) - 1 )
```
As can be seen these are very small rounding errors from the model generation.
These can be very hard to completely fix. Using the default value of `delta` 
(1e-13) means the model passes the checks.
```{r fix_redistribution}
```{r, test_model_pass}
check_model(model)
```
The value returned is a vector of the names of the expected time series input,
currently jus the a default value.

## Altering parameters

The parameter values are stored in the parameter vector ```model$parameters```. Each parameter
value has a unique name. In the current model the parameters are all set to
their default values:
```{r, default_param}
print(model$param)
```
The relationship between the parameters and the HRUs are given in the columns of
the HRU tables e.g.
```{r, hru_param}
## unsaturated zone time constant
head( model$hillslope[,c('id','td')])
```

Altering parameter values requires changing there values in the parameter
vector. For this catchment all HRU have the same parameter values. This
could be altered by changing parameter names in the HRU table and adding these
parameters to the parameter vector.

In this case we change the parameter vectors to me more representative of the
catchment
```{r, change_param}
model$param[c("srz_max_default","srz_0_default","ln_t0_default",
              "m_default","td_default","tsf_default")] <-
    c(0.1,0.98,1.15,0.0044,33,0.02)
```

# Preparing input data

The input to the model is expected to take the form of an ```xts``` object with
constant time step whose column names are found in the 'precip_input' and 'pet_input'
columns of the HRU table in the model. Helpful functions for creating and
manipulating ```xts``` objects can be found [here]{http://rstudio-pubs-static.s3.amazonaws.com/288218_117e183e74964557a5da4fc5902fc671.html}

The discharge, precipitation and potential evapotranspiration (PET) inputs for
Swindale and contained with `obs` on a 15 minute time step.
```{r, obs}
head(obs)
```
Note the discharge is in $m^{3}/s$ while the precipitation and PET are in m
accumulated over the timestep.

To use the data with the model we need to set the names of the time series
within the model. 
```{r, set_obs_names}
model$hillslope[,'precip'] <- model$channel[,'precip'] <- "Rainfall"
model$hillslope[,'pet'] <- model$channel[,'pet'] <- "PET"
```

The observed data can now be checked to ensure it is complete and contains the
correct series for the model
```{r, check obs, error=TRUE}
req_series <- check_model(model)
check_obs(obs, req_series)
```

From the return of ```check_obs``` we can see the time step of the data and default
number of sub time steps used in the model evaluation which is discussed
later.

# Running dynamic TOPMODEL

The model can be run with the data using the ```dyantop``` command.
```{r, run_1}
## recharge rate for initialization
initial_recharge <- as.numeric(obs[1,'Flow'])
## running the model
sim_1 <- dynatop(model,obs,initial_recharge)
```
The returned object from ```dynatop``` is a list with two elements
```{r, sim_out}
names(sim_1)
names(sim_1$model)
head(sim_1$channel_input)
```
which are an ```xts``` object of the flows to the channel HRUs at each time
step and the model passed to the call augmented with the final states of the
simulation.

In the above simulation the model was initialized using the flow at the start
of the event and used the default time step, which is the time step of the
input data. Sub stepping, that is using a finer numeric time step then the
data can improve the stability and quality of the simulations. The <>
parameter of the  ```dynatop``` function can be used to implement this. For
example
```{r, sub_step}
sim_2 <- dynatop(model,obs,initial_recharge,sim_time_step=5*60)
```
performs the same simulation with a 5 minute time step.

The output states of a simulation can be used to initialize the a subsequent
simulation. We note in doing this that no checks are made of the simulation
times periods or of the time steps used. For example
```{r, sim_initialization}
sim_3 <- dynatop(sim_1$model,obs,sim_time_step=5*60,use_states=TRUE)
```

The effects of the different implementations can be seem in the following
graph. Note that the discrepancy between the simulations and observed data is
due in part to the absence of any channel routing.
```{r, final_plot}
out <- merge( merge( merge(obs,sim_1$channel_input),
                    sim_2$channel_input),
             sim_3$channel_input)
names(out) <- c(names(obs),'sim_1','sim_2','sim_3')
out$qobs <- out$qobs*sum(model$hillslope$area)/3600
plot(out[event_period,c('qobs','sim_1','sim_2','sim_3')])
```
