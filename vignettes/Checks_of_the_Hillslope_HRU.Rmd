---
title: "Checks of the Hillslope HRU"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Checks of the Hillslope HRU}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
The purpose of this vignette is to demonstrate some simulation checks on the computation of hillslope elements. It provides both a check for
the current implimentation of the code and a demonstration for those that may
be developing more complex systems and want to perform their own test.

The basis of the simulations used in the test catchment contained within the
package which is loaded with
```{r, setup}
rm(list=ls())
library(dynatopDev)
data("test_catchment")
```

# Computing the volume of water in the hillslope
The volume of water in the hillslope can be computed from the states of the
system upto an additive constant. The volume in each hillslope HRU is given by
the sum of the surface excess, root zone, unsaturated zone and saturated zone
storages multiplied by the surface area. However only the storage deficit of saturated zone
is known. We therefore subtract this value and treat the unknown maximum
saturated zone storage as an unknown additive constant. Note that this can
result in apparently negatoive storages, but is adequate for the purposes of
assessing changes to storage.

In R this is implimented by the following function whose result is in m$^3$.
```{r vol_calc}
hillslope_volume <- function(mdl,ignore_ssz=FALSE){
  tmp <- mdl$states$hillslope
  if(!ignore_ssz){
    sum( tmp$area * (tmp$ex + tmp$srz + tmp$suz - tmp$ssz) )
  }else{
    sum( tmp$area * (tmp$ex + tmp$srz + tmp$suz) )
  }
}

```

# Initialising the model
In calling `dynatop` the states can either be provided as part 
of the model structure of can be initialised internally. Since the package
does not export a function for initialising the states within the model
structure the follwoing function is used:
```{r initialise_state_func}
init_model <- function(mdl, recharge){
  mdl$states <- list()
  mdl$states$hillslope <- initialise_hillslope(mdl,recharge)
  mdl$states$channel <- initialise_channel(mdl)
  return(mdl)
}  
```
However for
testing it is useful to be able to manipulate the states manually. 

# Saturated zone drain down

This check tests the performance of the saturated zone solution when there is
no flow from the unsaturated zone.
```{r ssz_drain_down}
## create a zero input and output forcing series
obs <- test_catchment$obs
obs$rain[] <- obs$pet[] <- 0

## initialise the model and set all stores except saturated zone to 0
initial_mdl <- init_model(test_catchment$model,0.015)
for(ii in c("ex","srz","suz")){
  initial_mdl$states$hillslope[[ii]][] <- 0
}

## simulate the model and seperate the output
out <- dynatop(initial_mdl,obs,use_states=TRUE)

## volume balance
initial_vol <- hillslope_volume(initial_mdl)
final_vol <- hillslope_volume(out$model)
channel_vol <- sum(out$channel_input) * unique(diff(.index(out$channel_input)))

## error as an average depth
abs(initial_vol - (final_vol + channel_vol)) / sum(out$model$states$hillslope$area)

```

# Saturated and unsaturated zone drain down
We repeat the saturated zone drain down test with initial unsaturated zone
storage but no forcing inputs.

```{r ssz_driven}
## create a zero input and output forcing series
obs <- test_catchment$obs
obs$rain[] <- obs$pet[] <- 0

## initialise the model and set all stores except saturated zone to 0
initial_mdl <- init_model(test_catchment$model,0.015)
for(ii in c("ex","srz")){
  initial_mdl$states$hillslope[[ii]][] <- 0
}

## simulate the model and seperate the output
out <- dynatop(initial_mdl,obs,use_states=TRUE)

## volume balance
initial_vol <- hillslope_volume(initial_mdl)
final_vol <- hillslope_volume(out$model)
channel_vol <- sum(out$channel_input) * unique(diff(.index(out$channel_input)))

## error as an average depth
abs(initial_vol - (final_vol + channel_vol)) / sum(out$model$states$hillslope$area)
```

# Surface excess movement
This tests the solution to the redistribution of surface storage with no
additional inflows
```{r ex_undriven}
## create a zero input and output forcing series
obs <- test_catchment$obs
obs$rain[] <- obs$pet[] <- 0

## initialise the model as 'dry' except for surface excess
initial_mdl <- init_model(test_catchment$model,0)
initial_mdl$states$hillslope$srz[] <- 0
initial_mdl$states$hillslope$ex[] <- 0.1

## simulate the model and seperate the output
out <- dynatop(initial_mdl,obs,use_states=TRUE)

## volume balance

initial_vol <- hillslope_volume(initial_mdl,TRUE)
final_vol <- hillslope_volume(out$model,TRUE)
channel_vol <- sum(out$channel_input) * unique(diff(.index(out$channel_input)))

# error as percent
abs(initial_vol - (final_vol + channel_vol)) / sum(initial_vol)*100
```

# All model with no evapotranspiration losses
This tests the solution assuming there is no loss to
evapotranspiration. testing beyond this requires the recording ot the losses
to evapotranspiration.
```{r all_no_pet}
## create a zero input and output forcing series
obs <- test_catchment$obs
obs$pet[] <- 0

## initialise the model as 'dry' except for surface excess
initial_mdl <- init_model(test_catchment$model,0.015)

## simulate the model and seperate the output
out <- dynatop(initial_mdl,obs,use_states=TRUE)

## volume balance
initial_vol <- hillslope_volume(initial_mdl)
final_vol <- hillslope_volume(out$model)
channel_vol <- sum(out$channel_input) * unique(diff(.index(out$channel_input)))
rain_vol <- sum(obs$rain) * (unique(diff(.index(out$channel_input)))/3600) *
  (sum(out$model$states$hillslope$area) + sum(out$model$states$channel$area))
# error as average over catchment
((initial_vol + rain_vol)- (final_vol + channel_vol)) / sum(out$model$states$hillslope$area)

```
