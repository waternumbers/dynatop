#' R6 Class for Dynamic TOPMODEL
#' @export

## START HERE:
## (iv) Impliment second channel routing?

dynatop <- R6::R6Class(
            "dynatop",
    public = list(
        #' @description Creates a dynatop class object from the a list based model description as generated by dynatopGIS.
        #'
        #' @param model a dynamic TOPMODEL list object
        #' @param use_states logical if states should be imported
        #' @param drop_map logical if the map should be dropped
        #' @param verbose if set prints out further information
        #' @param delta error term in checking redistribution sums
        #'
        #' @return invisible(self) suitable for chaining
        #'
        #' @details This function makes some basic consistency checks on a list representing a dynamic TOPMODEL model. The checks performed and basic 'sanity' checks. They do not check for the logic of the parameter values nor the consistncy of states and parameters. Sums of the redistribution matrices are checked to be in the range 1 +/- delta.
        initialize = function(model, use_states=FALSE, verbose=FALSE, delta = 1e-13){
            ## generate model description
            ##private$generate_model_description(model)
            ## check model will fail if there is an error
            private$check_model(model,use_states,verbose,delta)
            ## convert model here
            private$digest_model(model,use_states)
            invisible(self)
        },
        #' @description Adds observed data to a dynatop object
        #'
        #' @param obs_data an xts object of observed data
        #'
        #' @return invisible(self) suitable for chaining
        #'
        #' @details This function makes some basic consistency checks on the observations to ensure they have uniform timestep and all required series are present.
        add_data = function(obs_data){
            self$clear_data()
            ## check input and get model timestep
            private$check_obs(obs_data)
            private$digest_obs(obs_data)
            invisible(self)
        },
        #' @description Clears all forcing and simulation data except current states
        #'
        #' @return invisible(self) suitable for chaining
        clear_data = function(){
            private$time_series <- list()
            private$info$ts <- list()
        },
        #' @description Initialises a dynatop object in the simpliest way possible.
        #'
        #' @return invisible(self) suitable for chaining
        initialise = function(){
                       
            private$init_hs()
            private$init_ch()
            invisible(self)
        },
        #' @description Simulate the hillslope output of a dynatop object
        #' @param keep_states a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept
        #' @param sub_step simulation timestep in seconds, default value of NULL results in data time step
        #' @param solver whetther implicit or explict solver should be used
        #'
        #' @details Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
        sim_hillslope = function(keep_states=NULL,sub_step=NULL,solver=c("implicit","explicit")){

            ## check the solver option
            solver <- match.arg(solver)
            if(solver=="explicit"){stop("Not yet implimented")}
 
            
            ## check presence of states
            has_states <- all(sapply(private$model$hillslope,function(x){all(!is.na(x))}))
            if( !has_states ){
                stop("Model states are either not initialised or have non-finite values")
            }
            
            if( !is.null(sub_step) && !is.finite(sub_step[1]) ){
                stop("sub_step should be a single finite value")
            }
            
            ## check presense of obs
            if( length(private$time_series$index) < 2 ){
                stop("Insufficent data to perform a simulation")
            }
            
            ## check keep_states is valid
            if( length(keep_states)>0 ){
                if( !("POSIXct" %in% class(keep_states)) ){
                    stop("Times for returning states should be POSIXct object")
                }
            }
            keep_states <- keep_states[keep_states %in% private$time_series$index]
                        
            ## simulate
            private$sim_hs(keep_states,sub_step[1])

            invisible(self)
        },
        #' @description Simulate the channel output of a dynatop object
        #' @return invisible(self) for chaining
        sim_channel=function(){
           
            if(!private$info$can_solve_channel){
                stop("Cannot simulate channel - check connectivity")
            }
            
            ## check presence of channel_inflow
            if( nrow(private$time_series$channel_inflow$surface) !=
                length(private$time_series$index) ){
                stop("Suitable channel_inflow not available")
            }
            if( length(private$time_series$index) < 2 ){
                stop("Insufficent data to perform a simulation")
            }
            ## check initialised
            if(!("linear_time" %in% names(private$summary$channel))){
                stop("Channel solution is not initialised")
            }
            
                
           
            private$sim_ch()

            invisible(self)
        },
        #' @description Simulate the hillslope and channel componets of a dynatop object
        #' @param keep_states a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @param sub_step simulation timestep in seconds, default value of NULL results in data time step
        #' @param use_R shoudl the R version of the simulation code be used (default FALSE)
        #'
        #' @details Calls the sim_hillslope and sim_channel in sequence. Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
        #'
        #' @return invisible(self) for chaining
        sim = function(keep_states=NULL,sub_step=NULL){
            self$sim_hillslope(keep_states,sub_step)
            self$sim_channel()
            invisible(self)
        },
        ## ############
        ## Functions for extracting and plotting data
        #' @description Return channel inflow as an xts series or list of xts series
        #' @param total logical if plot total inflow is to be plotted
        #' @param separate logical if the surface and saturated zone inflows should be returned separately
        get_channel_inflow = function(total=FALSE,separate=FALSE){
            x <- private$time_series$channel_inflow
            if(total){
                x <- lapply(x,rowSums)
            }
            if(separate){
                x$surface <- xts::xts(x$surface,
                                   order.by=private$time_series$index)
                x$saturated <- xts::xts(x$saturated,
                                   order.by=private$time_series$index)
            }else{
                x <- x$surface + x$saturated
                x <- xts::xts(x,
                              order.by=private$time_series$index)
            }
            return(x)
        },
        #' @description Plot the channel inflow
        #' @param total logical if total inflow is to be plotted
        #' @param separate logical logical if the surface and saturated zone inflows should be plotted separately
        plot_channel_inflow = function(total=FALSE,separate=FALSE){
            x <- self$get_channel_inflow(total,separate)
            if(total){
                lloc <- NULL
                if(separate){
                    x <- merge(x$surface,x$saturated)
                    names(x) = c("surface","saturated")
                    lloc <- "topright"
                }
                plot(x,main="Channel Inflow",legend.loc=lloc)
            }else{
                x11();par(mfrow=c(2,1))
                plot(x$surface,main="Channel Inflow: surface",legend.loc=lloc)
                plot(x$saturated,main="Channel Inflow: saturated",legend.loc=lloc)
            }
        },
        #' @description Return flow at the gauges as an xts series
        #' @param gauge names of gauges to return (default is all gauges)
        get_gauge_flow = function(gauge=colnames(private$time_series$gauge_flow)){           
            gauge <- match.arg(gauge,colnames(private$time_series$gauge_flow),
                               several.ok=TRUE)
            xts::xts(private$time_series$gauge_flow[,gauge,drop=FALSE],
                     order.by=private$time_series$index)
        },
        #' @description Get the flow at gauges
        #' @param gauge names of gauges to return (default is all gauges)
        plot_gauge_flow = function(gauge=colnames(private$time_series$gauge_flow)){
            plot( self$get_gauge_flow(gauge),main="Simulated Flows",legend.loc="topright")
        },
        #' @description Get the observed data
        get_obs_data = function(){
            xts::xts(private$time_series$obs,
                     order.by=private$time_series$index)
        },
        #' @description Return the model
        get_model = function(){
            private$reform_model()
        },
        #' @description Return the model
        get_mass_errors = function(){
            if( !("mass_balance" %in% names(private$time_series)) ){
                stop("Mass errors are not available")
            }
            xts::xts(private$time_series$mass_balance,
                     order.by=private$time_series$index)
        },
        #' @description Return states
        #' @param record logical TRUE if the record should be returned. Otherwise the current states returned
        get_states = function(record=FALSE){
            if( record ){
                return( setNames(private$time_series$state_record,
                                 private$time_series$index) )
            }else{
                nm <- private$model_description[["hillslope"]]$name[private$model_description[["hillslope"]]$role=="state"]
                return( private$model$hillslope[,c("id",nm)] )
            }
       },
       #' @description Plot a current state of the system
       #' @param state the name of the state to be plotted
       #' @param add_channel Logical indicating if the channel should be added to the plot
       plot_state = function(state,add_channel=TRUE){
           
           if( is.null(private$model$map$hillslope) ){
               stop("The model contains no map of HSU locations")
           }
           if( !file.exists(private$model$map$hillslope) ){ stop("The model map file is missing") }
           if( add_channel & !file.exists(private$model$map$channel) ){ warnings("File containing the channel network does not exist") }
           
           if(!(state%in%colnames(private$model$hillslope))){
               stop("Model state does not exist")
           }
           
           if( !("raster" %in% rownames(installed.packages())) ){
               stop( "The raster package is required for plotting the maps of states - please install or add to libPath" )
           }
           
           ## x <- private$unpack$hillslope$state[,state]
           rst <- raster::raster(private$model$map$hillslope)
           rst <- raster::subs(rst, private$model$hillslope[,c("id",state)])
           
           raster::plot( rst)
           if( add_channel & file.exists(private$model$map$channel) ){
               chn <- raster::shapefile(private$model$map$channel)
               raster::plot(chn,add=TRUE)
           }
           
       }
       
    ),
    private = list(
        ## stores of data
        version = "0.2.0.9030",
        model = list(), # storage for model object
        summary = list(), # storage for intermediate computed values used in code
        time_series = list(),
        info = list(can_sim_channel=FALSE),
        ## decribes the model tables in terms of names, data type and role
        ## roles are either
        ## - attribute
        ## - parameter
        ## - data_series
        ## - state
        ## - output_label
        type_options = list(
            ## for each option type set the columns needed and the range of values
            hillslope = list(type_sz = list("exp" = data.frame(par = c("ln_t0","m"),
                                                               min = c(-Inf,0),
                                                               max=c(Inf,Inf)),
                                            "cnst" = data.frame(par = c("D","c_sz"),
                                                               min = c(0,0),
                                                               max=c(Inf,Inf)),
                                            "bexp" = data.frame(par = c("ln_t0","m","D"),
                                                               min = c(-Inf,0,0),
                                                               max=c(Inf,Inf,Inf)),,
                                            "dexp" = data.frame(par = c("ln_t0","m","m_2","omega"),
                                                               min = c(-Inf,0,0,0),
                                                               max=c(Inf,Inf,Inf,1))
                                            )
                             )
        ),
        model_description = list(
            ## hillslope data frame
            hillslope = data.frame(
                name = c("id","atb_bar","s_bar","area","width","type_sz", ## attributes associated with hru
                         "r_sfmax","c_sf","s_rzmax","s_rz0","t_d","r_uz_sz0","ln_t0","c_sz","m","D","m_2","omega", ## parameters
                         "s_sf","s_rz","s_uz","s_sz"), # state names
                role = c(rep("attribute",6),
                         rep("parameter",12),
                         rep("state",4)),
                type = c("integer",rep("numeric",4),"character",
                         rep("numeric",12),
                         rep("numeric",4))
            ),
            ## channel data frame
            channel =  data.frame(
                name= c("id","area","length", # attributes
                        "v_ch" # parameters
                        ),
                role = c(rep("attribute",3),
                         rep("parameter",1)),
                type = c("integer",rep("numeric",2),
                         "numeric")
            ),
            ## linkages between HSUs
            flow_direction = data.frame(
                name= c("from","to","frc"),
                role = rep("attribute",3),
                type = c(rep("integer",2),"numeric"),
                stringsAsFactors=FALSE),
            ## rainfall inputs
            precip_input = data.frame(
                name = c("name","id","frc"),
                type=c("character","integer","numeric"),
                role = c("data_series",rep("attribute",2)),
                stringsAsFactors=FALSE),
            ## pet inputs
            pet_input = data.frame(
                name = c("name","id","frc"),
                type=c("character","integer","numeric"),
                role = c("data_series",rep("attribute",2)),
                stringsAsFactors=FALSE),
            ## point inflow to channels
            point_inflow = data.frame(
                name = c("name","id"),
                type=c("character","integer"),
                role = c("data_series","attribute"),
                stringsAsFactors=FALSE),
            ## diffuse inflow to channels
            diffuse_inflow = data.frame(
                name = c("name","id"),
                type=c("character","integer"),
                role = c("data_series","attribute"),
                stringsAsFactors=FALSE),
            ## location of gauges
            gauge = data.frame(
                name = c("name","id"),
                type=c("character","integer"),
                role = c("output_label","attribute"),
                stringsAsFactors=FALSE)
        ),
        ## this code checks the model
        check_model = function(model, use_states, verbose, delta=1e-13){
            
            ## check all components of the model exist
            components <- names(private$model_description)
            idx <- components %in% names(model)
            if( !all(idx) ){
                stop(paste("Missing componets:",paste(components[!idx],collapse=",")))
            }

            ## check the HRU table properties
            req_names <- list(output_label = list(),
                              data_series = list())
            for(ii in components){
                ## what should the properties of each column be
                prop <- private$model_description[[ii]]
                if(!use_states){
                    prop <- prop[ !(prop$role=="state"), ]
                }
                                
                if(!is.data.frame(model[[ii]])){
                    stop(paste("Table",ii,"should be a data.frame"))
                }
        
                idx <- prop$name %in% names(model[[ii]])
                
                if( !all( idx ) ){# check it has required columns
                    stop( paste("Table",ii,"is missing columns:",
                                paste(prop$name[!idx],collapse=",")) )
                }
                
                ## check data types               
                tmp <- sapply(model[[ii]],class) # types of the columns
                idx <- tmp[ prop$name ] != prop$type
                if( any( idx ) ){
                    stop( paste("Incorrect types in table",ii,"columns:",
                                paste(prop$name[idx],collapse=",")) )
                }

                ## check all numeric values are finite and positive if not parameters
                idx <- setNames(rep(FALSE,length(prop$name)),prop$name)
                for(jj in prop$name[prop$type=="numeric" & !(prop$role=="parameter")]){
                    if(any(!is.finite(model[[ii]][[jj]])) | !all(model[[ii]][[jj]]>=0)){
                        idx[jj] <- TRUE
                    }
                }
                if(any(idx)){
                    stop("Non-finite or negative values in table ",ii," columns: ",
                         paste(prop$name[idx],collapse=", "))
                }

                



                
                ## take the required names
                for(jj in names(req_names)){
                    tmp <- prop$name[prop$role==jj]
                    req_names[[jj]][[ii]] <- unlist(model[[ii]][,tmp])
                }
            }

            ## check the common hillslope parameters
            idx <- setNames(rep(FALSE,6),c("r_sfmax","c_sf","s_rzmax","s_rz0","t_d","r_uz_sz0"))
            for(jj in names(idx)){
                if(any(!is.finite(model[[ii]][[jj]])) | !all(model[[ii]][[jj]]>=0)){
                    idx[jj] <- TRUE
                }
            }
            if(any(idx)){
                stop("Non-finite or negative values in table hillslope columns: ",
                     paste(prop$name[idx],collapse=", "))
            }

            ## check the type dependent hillslope parameters
            for(jj in names(private$type_options$hillslope)){## loop options
                str <- ""
                for(ii in names(private$type_options$hillslope[[jj]])){ ## loop types for option
                    jdx <- model$hillslope[[jj]] == ii
                    if( any(jdx) ){
                        tmp <- private$type_options$hillslope[[jj]][[ii]] ## data frame of limits
                        for(kk in 1:nrow(tmp)){
                            if( !all(is.finite(model$hillslope[[ tmp$par[kk] ]])) |
                                any( model$hillslope[[ tmp$par[kk] ]] < tmp$min[kk]) |
                                any( model$hillslope[[ tmp$par[kk] ]] > tmp$max[kk]) ){
                                str <- paste(str,
                                             paste("For type",ii,
                                                   "the value of",tmp$par[kk],
                                                   "must be between",tmp$min[kk],"and",tmp$max[kk]),sep="\n")
                            }
                        }
                    }
                }
                if(nchar(str)>0){
                    stop(paste0("Error in ",jj,":\n",str))
                }
            }

            ## check the common channel parameters
            idx <- setNames(rep(FALSE,1),c("v_ch"))
            for(jj in names(idx)){
                if(any(!is.finite(model[[ii]][[jj]])) | !all(model[[ii]][[jj]]>=0)){
                    idx[jj] <- TRUE
                }
            }
            if(any(idx)){
                stop("Non-finite or negative values in table channel columns: ",
                     paste(prop$name[idx],collapse=", "))
            }              
            
            ## unpack the required names to vectors
            for(jj in names(req_names)){
                req_names[[jj]] <- do.call(c,req_names[[jj]])
            }
                        
            ## check all output series have unique names
            if( length(req_names$output_names) != length(unique(req_names$output_names)) ){
                stop("All output series should have a unique name")
            }
            
            ## checks on hillslope and channel HSU ids
            all_hsu <- c(model$hillslope$id,model$channel$id)
            if( length(all_hsu) != length(unique(all_hsu)) ){
                stop("HSU id values should be unique") }
            if( !all(is.finite(all_hsu)) ){ stop("HSU id values should be finite") }
            if( !all(range(all_hsu)==c(1,length(all_hsu))) ){
                stop("HSU id's should be numbered consecuativly from 1")
            }
            
            ## all points_inflows and gauges should be on a channel
            ## with fractions between 0 & 1
            for(jj in c("gauge","point_inflow")){
                if(nrow(model[[jj]]) == 0){next}
                idx <- (model[[jj]]$id %in% model[['channel']]$id) &
                    (model[[jj]]$fraction >= 0) &
                    (model[[jj]]$fraction <= 1)
                if( any(!idx) ){
                    stop(paste("The following", jj , "are incorrectly specified:",
                               paste(model[[jj]]$name[!idx],collapse=" ")))
                }
            }
            
            ## all diffuse inflows should be to channels
            if(nrow(model[["diffuse_inflow"]]) > 0){
                if( any(!(model[[jj]]$id %in% model[['channel']]$id)) ){
                    stop(paste("The following diffuse_inputs are incorrectly specified:",
                               paste(model[["diffuse_input"]]$name[!idx],collapse=" ")))
                }
            }
            
            ## checks on flow directions
            if(!all( model$flow_direction$from %in% all_hsu )){
                stop("Flow link for unspecified HSU")
            }
            if(!all( model$flow_direction$to %in% all_hsu )){
                stop("Flow link to unspecified HSU")
            }
            if(!all( model$flow_direction$to < model$flow_direction$from )){
                stop("Flow link going to a HSU with higher id - out of order")
            }
            
            tmp <- tapply(model$flow_direction$frc,model$flow_direction$from,sum)
            tmp_idx <- abs(tmp-1)<delta
            if(!(all(tmp_idx))){
                stop("Flow direction fractions in the flow of HSU id's do not sum to 1: ",
                     paste(names(tmp[!idx]),collapse=", "))
            }

            ## check on rainfall and pet input
            all_hsu_area <- setNames(c(model$channel$area,model$hillslope$area),
                                     c(model$channel$id,model$hillslope$id))
            all_hsu_area <- all_hsu_area[paste(all_hsu)] ## set in same order as all hsu
            for(ii in c("precip_input","pet_input")){
                tmp <- tapply(model[[ii]]$frc,model[[ii]]$id,sum)
                tmp_idx <- abs(tmp-1)<delta
                if(!(all(tmp_idx))){
                    stop(paste(ii,"fractions for the following HSU id's do not sum to 1: "),
                         paste(names(tmp[!tmp_idx]),collapse=", "))
                }
                tmp_idx <- all_hsu %in% names(tmp) | all_hsu_area == 0
                if(!all(tmp_idx)){
                    warning(paste0("The following HSUs do not receive ",ii," and have area greater then 0: "),
                            paste(all_hsu[!tmp_idx],collapse=", "))
                }
                if(!all( model[[ii]]$id %in% all_hsu )){
                    stop(paste(ii,"contains id not in HSU tables"))
                }
            }

            ## specific check on hillslope
            if(!all(model$hillslope$id %in% model$flow_direction$from)){
                stop("Hillslope HSU cannot be an outlet or a sink")
            }
            
            ## specific checks on channel network connectivity
            n_chn_con <- setNames(rep(0,length(model$channel$id)),
                                  model$channel$id)
            tmp <- table(model$flow_direction$from)
            nm <- intersect(paste(model$channel$id),names(tmp))
            n_chn_con[nm] <- tmp[nm]
            
            if( any(n_chn_con>1) ){
                warning("Only channel HSUs routing to single channel HSUs are supported",
                        "\n",
                        "Channels HSUs with multiple downstream connections are ids: ",
                        paste(names(n_chn_con[n_chn_con>1]),collapse=", "))
                private$info$can_solve_channel <- FALSE
            }else{
                private$info$can_solve_channel <- TRUE
            }

            ## trim to just links from channels
            cfd <- model$flow_direction[ model$flow_direction$from %in% model$channel$id,]
            if(!all(cfd$to %in% model$channel$id)){
                stop("Channel's must flow to channel's")
            }

            #browser()
            is_outlet <- names(n_chn_con[n_chn_con==0]) # no flow from it so outlet
            to_outlet <- rep(FALSE,nrow(cfd))
            to_outlet[cfd$to %in% is_outlet] <- TRUE
            chng <- TRUE
            while(chng){
                idx <- which( cfd$to %in% cfd$from[to_outlet] )
                chng <- any(to_outlet[idx]==FALSE)
                to_outlet[idx] <- TRUE
            }
            if(!all(to_outlet)){
                stop("Some channels do not reach an outlet")
            }

            ## Checks maps exist
            tmp <- sapply(model$map,file.exists)
            if(!all(tmp)){
                warning("The following maps are missing:\n",
                         paste(names(tmp[!tmp]),collapse=", "))
            }
            
            ## if here we have passed all tests then return
            invisible( self )
            
        },

        ## convert the form of the model for internal storage
        ## we presume the model has been checked!!
        digest_model = function(model,use_states){
            ## It is important that variables are sorted by decreasing id
            ## No check is made for this in the C++ code!!
            ## variables appear in the matrices in the order of model_description
            ## it is important the C++ code matches this

            ## Assume everthing is numeric except for id's which are integer

            ## unpack hillslope and channel sorting by id and handling states
            
            for(ii in c("hillslope","channel")){
                model[[ii]] <-
                    model[[ii]][order(model[[ii]]$id,decreasing=TRUE),] ## sorting

                ## handle states
                if(!use_states){
                    nm <- private$model_description[[ii]]$name[private$model_description[[ii]]$role=="state"]
                    model[[ii]][nm] <- as.numeric(NA)
                }
                private$model[[ii]] <- model[[ii]]
            }

            ## convert types into integer values and set values based on type
            for(ii in names(private$type_options)){
                for(jj in names(private$type_options[[ii]])){
                    tmp <- private$type_options[[ii]][[jj]]
                    tmp <- setNames(seq_along(tmp),tmp)                    
                    private$model[[ii]][[jj]] <- tmp[ private$model[[ii]][[jj]] ]
                }
            }
            
            ## unpack inputs - sorted but this is not used might be better to sort for speed?
            for(ii in c("precip_input","pet_input")){
                model[[ii]] <-
                    model[[ii]][order(model[[ii]]$id,decreasing=TRUE),] ## sorting
                private$model[[ii]] <- model[[ii]]
            }

            ## unpack flow direction - sorting is used here
            private$model$flow_direction <-
                model$flow_direction[order(model$flow_direction$from,decreasing=TRUE),] ## sort
            
            ## channel inflows, gauge locastions etc - just copy..
            for(ii in c("diffuse_inflow","point_inflow","gauge","map")){
                private$model[[ii]] <- model[[ii]]
            }
            
            ## work out all the required input series
            data_series <- list()
            for(tbl in names(private$model_description)){
                prop <- private$model_description[[tbl]]
                ii <- prop$name[prop$role=="data_series"]
                data_series[[tbl]] <- unique( unlist( model[[tbl]][,ii]) )
            }
            
            private$info$data_series <- unique( do.call(c,data_series) )
            
            invisible( self )
        },
        ## convert the form the internal storage to that input
        ## we presume the model has been checked!!
        reform_model = function(){

            ## convert types back into strings
            for(ii in names(private$type_options)){
                for(jj in names(private$type_options[[ii]])){
                    tmp <- private$type_options[[ii]][[jj]]
                    private$model[[ii]][[jj]] <- tmp[ private$model[[ii]][[jj]] ]
                }
            }

            out <- private$model
            return(out)
        },        
        ## check and add obsservations
        check_obs = function(obs){
            req_series <- private$info$data_series

            ## check types
            if(!is.xts(obs)){ stop("observations should be an xts object") }
            if(!is.vector(req_series) | !all(sapply(req_series,class)=='character') ){ stop("req_series should be a character vector") }
            
            ## check we have all the series needed
            if( !all( req_series %in% names(obs) ) ){
                stop("Missing input series:",setdiff( req_series , names(obs) ))
            }

            ## check constant time step
            tmp <- diff(as.numeric(index(obs)))
            if( !all( tmp == tmp[1] ) ){
                stop("Time steps in data are not unique")
            }
            
            ## check all values are finite
            if( !all(is.finite(obs[,req_series])) ){
                stop("There are non finite values in the required time series")
            }
        },
        digest_obs = function(obs){
            ## Assumes all checks passed
            private$time_series$obs_data <- as.matrix(obs)
            private$time_series$index <- index(obs)

            ## set up the column vectors for the rainfall and pet
            private$summary$precip_input <- private$model$precip_input
            private$summary$precip_input$col_idx <- as.integer(
                match(private$model$precip_input$name, colnames(private$time_series$obs)) - 1) # minus 1 to get C++ index
            private$summary$pet_input <- private$model$pet_input
            private$summary$pet_input$col_idx <- as.integer(
                match(private$model$pet_input$name, colnames(private$time_series$obs)) -1 ) # minus 1 to get C++ index
        },
        ## compute the simulation timestep
        comp_ts = function(sub_step=NULL){
            ## work out time steps for use in simulation
            ts <- list()
            ts$step <- diff(as.numeric(private$time_series$index[1:2])) # seconds
            if(is.null(sub_step)){sub_step <- ts$step}
            ts$n_sub_step <- max(1,floor(ts$step/sub_step)) # dimensionless
            ts$sub_step <- ts$step / ts$n_sub_step
            private$info$ts <- ts
        },
        ## ###########################################
        ## Initialise the states
        init_hs = function(){
            dt_init(private$model$hillslope,
                    private$model$channel,
                    private$model$flow_direction)
        },
        ## ###############################
        ## function to perform simulations
        sim_hs = function(keep_states,sub_step,solver){
                        
            if(!all(is.finite(private$model$hillslope$states))){
                stop("States have a non-finite value - may need initialising")
            }
            
            ## compute time substep
            if( !is.null(sub_step) && !is.finite(sub_step[1]) ){
                stop("sub_step should be a single finite value")
            }
            ts <- private$comp_ts(sub_step)

            ## work out the courant numbers
            courant <- matrix(as.numeric(NA),length(private$model$hillslope$id),2)
            dt_courant(private$model$hillslope,courant,ts$step,ts$n_sub_step)
            
            ## Display number of sub steps required
            if( any(courant[,1]>0.7) ){
                warning("Courant number for surface zone is over 0.7\n",
                        "Suggest maximum sub step is: ",
                        round( min( (0.7/courant[,1]) * (ts$step/ts$n_sub_step) ),2 ),
                        "seconds")
            }
            if( any(courant[,2]>0.7) ){
                warning("Courant number for saturated zone is over 0.7\n",
                        "Suggest maximum sub step is: ",
                        round( min( (0.7/courant[,2]) * (ts$step/ts$n_sub_step) ),2 ),
                        "seconds")
            }
            

            ## Logical if states to be kept and store
            keep_states <- private$time_series$index %in% keep_states
            if(any(keep_states)){
                private$time_series$state_record <- rep(list(as.data.frame(NULL)),length(private$time_series$index))
            }else{
                private$time_series$state_record <- list()
            }

            ## Initialise the mass error store
            private$time_series$mass_balance <- matrix(as.numeric(NA),nrow(private$time_series$obs),6)
            colnames(private$time_series$mass_balance) <-
                c("initial_state","e_t","p","channel_inflow","final_state","error")

            ## set up  channel_inflow
            ## cpode prior to splitting inputs
            ## private$time_series$channel_inflow <- matrix(as.numeric(NA),
            ##                                              nrow(private$time_series$obs),
            ##                                              length(private$model$channel$id))
            ## colnames(private$time_series$channel_inflow) <- private$model$channel$id
            private$time_series$channel_inflow <- list(surface = matrix(as.numeric(NA),
                                                                     nrow(private$time_series$obs),
                                                                     length(private$model$channel$id)),
                                                       saturated = matrix(as.numeric(NA),
                                                                     nrow(private$time_series$obs),
                                                                     length(private$model$channel$id)))
                                                       
            colnames(private$time_series$channel_inflow$surface) <- colnames(private$time_series$channel_inflow$saturated) <- private$model$channel$id

            dt_implicit_sim(private$model$hillslope,
                            private$model$channel,
                            private$model$flow_direction,
                            private$summary$precip_input,
                            private$summary$pet_input,
                            private$time_series$obs,
                            private$time_series$channel_inflow$surface,
                            private$time_series$channel_inflow$saturated,
                            private$time_series$mass_balance,
                            as.logical( keep_states ),
                            private$time_series$state_record,
                            ts$step,
                            ts$n_sub_step
                            )
        },
        ## #############################
        init_ch = function(){
            channel <- private$model$channel
            gauge <- private$model$gauge
            point_inflow <- private$model$point_inflow
            
            ## get the channels upstream of each id
            chn_con <- lapply(channel$id,
                              function(x){
                                  ## work out links going to reach from channels
                                  idx <- (private$model$flow_direction$to==x) &
                                      (private$model$flow_direction$from %in% channel$id)
                                  ## limit to only channels
                                  return( paste(private$model$flow_direction$from[idx]) )
                              }
                              )
            names(chn_con) <- paste(channel$id)
            
            
            ## compute the time to travel down each reach
            reach_time <- setNames( channel[,"length"] / channel[,"v_ch"], #private$model$param[channel$v_ch],
                                   channel$id )

            ## storage for output
            linear_time <- setNames(rep(list(NULL),length(gauge$name)),
                                    gauge$name)
            
            ## Loop gauges
            for(gnm in 1:length(gauge$name)){
                ## initialise diffuse input matrix
                df <- matrix(as.numeric(NA),length(channel$id),2)
                colnames(df) <- c("min_time","max_time")
                rownames(df) <- channel$id
                ## start with location of the gauge
                idx <- paste(gauge$id[gnm])
                df[idx,"min_time"] <- 0
                while(length(idx)>0){
                    ii <- idx[1] ## current reach
                    df[ii,"max_time"] <- df[ii,"min_time"] + reach_time[ii] ## work out max time
                    jdx <- chn_con[[ii]] ## get upstream reaches
                    df[jdx,"min_time"] <- df[ii,"max_time"] ## set min time to max time of downstream
                    idx <- c(idx[-1],jdx)
                }
                ## initialise the point inflow matrix
                ii <- paste(point_inflow$id) ## find id of reach
                pnt <- df[ii,] ## copy rows of df table
                pnt[,"min_time"] <- pnt[,"max_time"] # since point inflow at head of reach
                rownames(pnt) <- point_inflow$name ## rename

                ## trim locations that don't go to that gauge
                df <- df[is.finite(df[,"min_time"])&is.finite(df[,"max_time"]),]
                pnt <- pnt[is.finite(pnt[,"min_time"])&is.finite(pnt[,"max_time"]),]

                linear_time[[gnm]] <- list(diffuse=df,point=pnt)
            }
                        
            private$summary$channel$linear_time <- linear_time
        },
        sim_ch = function(){
            ## initialise the output
            out <- matrix(NA,length(private$time_series$index),
                          length(private$summary$channel$linear_time))
            colnames(out) <- names(private$summary$channel$linear_time)
            

            ## ## function to make polynonial representing time delay histogram
            ## ## this works for instananeous flows
            ## fpoly <- function(x){
            ##     if( x["min_time"] == x["max_time"] ){
            ##         ## point input
            ##         ms <- floor(x["max_time"]/private$info$ts$step)+1
            ##         ply <- rep(0,ms)
            ##         ply[ms] <- 1
            ##     }else{
            ##         ms <- ceiling(x["max_time"]/private$info$ts$step)
            ##         #ply <- rep(NA,ms)
            ##         fnsh <- (1:ms)*private$info$ts$step
            ##         strt <- fnsh - private$info$ts$step
            ##         strt <- pmax(strt,x["min_time"])
            ##         fnsh <- pmin(fnsh,x["max_time"])
            ##         ply <- pmax(0,fnsh-strt)
            ##     }
            ##     return(ply/sum(ply))
            ## }
            ## function for point inputs
            fp <- function(x){
                tau0 <- x["min_time"]
                tauL <- x["max_time"]-x["min_time"]
                Dt <- private$info$ts$step
                rL <- floor((tau0+tauL)/Dt)
                irL <- rL+1 ## index in vector since R starts at 1 not zero
                b <- rep(0,irL+1)
                b[irL] <- ((rL+1)*Dt - tau0-tauL)/Dt
                b[irL+1] <- (tau0+tauL - rL*Dt)/Dt
                return(b)
            }
            ## function for diffuse inputs
            fd <- function(x){
                tau0 <- x["min_time"]
                tauL <- x["max_time"]-x["min_time"]
                Dt <- private$info$ts$step
                r0 <- floor(tau0/Dt)
                ir0 <- r0+1 ## index in vector since R starts at 1 not zero
                rL <- floor((tau0+tauL)/Dt)
                irL <- rL+1 ## index in vector since R starts at 1 not zero
                b <- rep(0,irL+1)
                
                if(rL>r0){
                    b[ir0:(irL-1)] <- Dt # inital values valid unless over written
                    b[ir0] <- ( ((r0+1)*Dt - tau0)^2 ) / (2*Dt)
                    b[ir0+1] <- b[ir0] + ( ((r0+1)*Dt - tau0)*(tau0 - (r0*Dt)) ) / Dt
                    b[irL+1] <- ( (tau0+tauL - (rL*Dt))^2 ) / (2*Dt)
                    b[irL] <- b[irL] + b[irL+1] + ( ((tau0+tauL - (rL*Dt))*((rL+1)*Dt - tau0-tauL)) / Dt ) ## added to self since rL could equal r0+1
                    if( rL > (r0+1) ){
                        b[ir0+1] <- b[ir0+1] + Dt/2
                        b[irL] <- b[irL] + Dt/2
                    }
                }else{
                    b[ir0] <- (tauL/Dt)*( (r0+1)*Dt - tau0 - (tauL/2) )
                    b[ir0+1] <- (tauL/Dt)*(tau0 + (tauL/2) - r0*Dt )
                }
                
                return(b/sum(b)) #this should really be b*v_ch/L
            }
            
            ## Loop gauges
            for(gnm in names(private$summary$channel$linear_time)){

                ## initialise the point - set to 0
                out[,gnm] <- 0

                ## diffuse inputs
                df <- private$summary$channel$linear_time[[gnm]]$diffuse

                for(ii in rownames(df)){
                    ply <- fd(df[ii,]) ##fpoly(df[ii,])
                    ## compute input
                    x <- private$time_series$channel_inflow$surface[,ii] +
                        private$time_series$channel_inflow$saturated[,ii]
                    ## add diffuse inputs to x
                    idx <- paste(private$model$diffuse_inflow$id)==ii
                    nm <- private$model$diffuse_inflow$name[idx]
                    x <- x + rowSums(private$time_series$obs[,nm])
                    ## pas and filter
                    np <- length(ply)-1
                    x <- c(rep(x[1],np),x)
                    q <- filter(x,ply,method="conv",sides=1)
                    if(np>0){q <- q[-(1:np)]}
                    out[,gnm] <- out[,gnm] + q
                }

                ## handle point inputs
                pnt <- private$summary$channel$linear_time[[gnm]]$point
                ## loop point inputs upstream
                for(ii in rownames(pnt)){
                    ply <- fp(pnt[ii,]) ##fpoly(pnt[ii,])
                    np <- length(ply)-1
                    ## compute input
                    x <- private$time_series$obs[,ii]
                    x <- c(rep(x[1],np),x)
                    ## apply polynomial
                    q <- filter(x,ply,method="conv",sides=1)
                    if(np>0){q <- q[-(1:np)]}
                    out[,gnm] <- out[,gnm] + q
                }
            }

            private$time_series$gauge_flow <- out
        }
    )
    )

    
    
