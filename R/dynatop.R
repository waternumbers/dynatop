#' R6 Class for Dynamic TOPMODEL
#' @export

dynatop <- R6::R6Class(
    "dynatop",
    public = list(
        #' @description Creates a dynatop class object from the a list based model description as generated by dynatopGIS.
        #'
        #' @param model a dynamic TOPMODEL list object
        #' @param use_states logical if states should be imported
        #' @param verbose if set prints out further information
        #' @param delta error term in checking redistribution sums
        #'
        #' @return invisible(self) suitable for chaining
        #'
        #' @details This function makes some basic consistency checks on a list representing a dynamic TOPMODEL model. The checks performed and basic 'sanity' checks. They do not check for the logic of the parameter values nor the consistncy of states and parameters. Sums of the redistribution matrices are checked to be in the range 1 +/- delta.
        initialize = function(model, use_states=FALSE, verbose=FALSE, delta = 1e-13){
            ## check model will fail if there is an error
            private$check_model(model,use_states,verbose,delta)
            ## convert model here
            private$digest_model(model)
            invisible(self)
        },
        #' @description Adds observed data to a dynatop object
        #'
        #' @param obs_data an xts object of observed data
        #'
        #' @return invisible(self) suitable for chaining
        #'
        #' @details This function makes some basic consistency checks on the observations to ensure they have uniform timestep and all required series are present.
        add_data = function(obs_data){
            self$clear_data()
            ## check input and get model timestep
            private$check_obs(obs_data)
            invisible(self)
        },
        #' @description Clears all forcing and simulation data except current states
        #'
        #' @return invisible(self) suitable for chaining
        clear_data = function(){
            private$time_series <- list()
            private$info$ts <- list()
        },
        #' @description Initialises a dynatop object in the simpliest way possible.
        #'
        #' @param initial_recharge Initial recharge to the saturated zone in steady state in m/s
        #'
        #' @return invisible(self) suitable for chaining
        initialise = function(initial_recharge){
            
            ## check initial discharge
            if( !is.numeric(initial_recharge) | length(initial_recharge) > 1 | any( initial_recharge < 0 ) ){
                stop("Initial discharge should be a single positive numeric value")
            }
            
            private$init_hs(initial_recharge)
            private$init_ch()
            invisible(self)
        },
        #' @description Simulate the hillslope output of a dynatop object
        #' @param keep_states a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @param sub_step simulation timestep in seconds, default value of NULL results in data time step
        #' @param use_R shoudl the R version of the simulation code be used (default FALSE)
        #'
        #' @details Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
        sim_hillslope = function(mass_check=FALSE,keep_states=NULL,sub_step=NULL,
                                 use_R=FALSE){
            ## check presence of states
            tmp <- private$model_description$hillslope
            if( !all(tmp$name[tmp$role=="state"] %in% names(private$model$hillslope)) ){
                stop("Model states are not initialised")
            }

            if( !is.null(sub_step) && !is.finite(sub_step[1]) ){
                stop("sub_step should be a single finite value")
            }
            
            ## check presense of obs
            if( length(private$time_series$index) < 2 ){
                stop("Insufficent data to perform a simulation")
            }
            
            ## check keep_states is valid
            if( length(keep_states)>0 ){
                if( !("POSIXct" %in% class(keep_states)) ){
                    stop("Times for returning states should be POSIXct object")
                }
            }
            keep_states <- keep_states[keep_states %in% private$time_series$index]
                        
            ## simulate
            private$sim_hs(mass_check,keep_states,sub_step[1],use_R)

            invisible(self)
        },
        #' @description Simulate the channel output of a dynatop object
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @return invisible(self) for chaining
        sim_channel=function(mass_check=FALSE){
            if(mass_check){
                ## TODO add a mass check
                warning("Channel mass check not yet implimented")
            }
            ## check presence of channel_inflow
            if( nrow(private$time_series$channel_inflow) !=
                length(private$time_series$index) ){
                stop("Suitable channel_inflow not available")
            }
            if( length(private$time_series$index) < 2 ){
                stop("Insufficent data to perform a simulation")
            }
            private$sim_ch()

            invisible(self)
        },
        #' @description Simulate the hillslope and channel componets of a dynatop object
        #' @param keep_states a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @param sub_step simulation timestep in seconds, default value of NULL results in data time step
        #' @param use_R shoudl the R version of the simulation code be used (default FALSE)
        #'
        #' @details Calls the sim_hillslope and sim_channel in sequence. Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
        #'
        #' @return invisible(self) for chaining
        sim = function(mass_check=FALSE,keep_states=NULL,sub_step=NULL,use_R=FALSE){
            self$sim_hillslope(mass_check,keep_states,sub_step,use_R)
            self$sim_channel()
            invisible(self)
        },
        ## ############
        ## Functions for extracting and plotting data
        #' @description Return channel inflow as an xts series
        #' @param total logical if plot total inflow is to be plotted
        get_channel_inflow = function(total=FALSE){
            ## browser()
            x <- private$time_series$channel_inflow
            if(total){
                x <- rowSums(x)
            }
            xts::xts(x,
                     order.by=private$time_series$index)
        },
        #' @description Plot the channel inflow
        #' @param total logical if plot total inflow is to be plotted
        plot_channel_inflow = function(total=FALSE){
            ## browser()
            x <- self$get_channel_inflow(total)
            plot(x)
        },
        #' @description Return flow at the gauges as an xts series
        #' @param gauge names of gauges to return (default is all gauges)
        get_gauge_flow = function(gauge=colnames(private$time_series$gauge_flow)){
            ## browser()
            gauge <- match.arg(gauge,colnames(private$time_series$gauge_flow),
                               several.ok=TRUE)
            xts::xts(private$time_series$gauge_flow[,gauge],
                     order.by=private$time_series$index)
        },
        #' @description Get the flow at gauges
        #' @param gauge names of gauges to return (default is all gauges)
        plot_gauge_flow = function(gauge=names(private$time_series$gauge_flow)){
            ## browser()
            plot( self$get_gauge_flow(gauge) )
        },
        #' @description Get the observed data
        get_obs_data = function(){
            ## browser()
            xts::xts(private$time_series$obs,
                     order.by=private$time_series$index)
        },
        #' @description Return the model
        get_model = function(){
            private$reform_model()
        },
        #' @description Return the model
        get_mass_errors = function(){
            ## browser()
            if( !("mass_errors" %in% names(private$time_series)) ){
                stop("Mass errors are not available")
            }
            xts::xts(private$time_series$mass_errors,
                     order.by=private$time_series$index)
        },
        #' @description Return states
        #' @param record logical TRUE if the record should be returned. Otherwise surrent states returned
        get_states = function(record=FALSE){
            ## if( nrow(private$time_series$channel_inflow == 0) ){
            ##     stop("No simulation is available")
            ## }
            ## browser()
            if( record ){
                
                return( setNames(private$time_series$state_record,
                                 private$time_series$index) )
            }else{
                return( private$extract_states(private$model$hillslope,"hillslope") )
            }            
        },
        #' @description Plot a current state of the system
        #' @param state the name of the state to be plotted
        plot_state = function(state){
            if( !("raster" %in% rownames(installed.packages())) ){
                stop( "The raster package is required for plotting the maps of states - please install or add to libPath" )
            }
            
            
            
            tmp <- private$model_description$hillslope
            if( !all(tmp$name[tmp$role=="state"] %in% names(private$model$hillslope)) ){
                stop("Model states are not initialised")
            }
            
            state <- match.arg(state,tmp$name[tmp$role=="state"])
            x <- setNames(
                private$extract_states(private$model$hillslope,"hillslope")[,state],
                private$model$hillslope$id)
            x <- x[paste(private$model$map$hillslope)]
            
            raster::plot( raster::raster(crs = private$model$map$scope$crs,
                                 ext = private$model$map$scope$ext,
                                 resolution = private$model$map$scope$res,
                                 vals = x) )
        }
        
    ),
    private = list(
        ## stores of data
        version = 0.12,
        time_series = list(),
        info = list(),
        model = NULL,
        ## decribes a model tables
        ## roles are either
        ## - attribute
        ## - parameter
        ## - data_series
        ## - state
        ## - output_label
        model_description = list(
            hillslope = data.frame(name = c("id","atb_bar","s_bar","area","delta_x","sz_dir","sf_dir", # attributes associated with catchment HSU
                                            "precip","pet", # names of input series
                                            "q_sfmax","s_rzmax","s_rz0","ln_t0","m","t_d","t_sf", # parameter names
                                            "s_sf","s_rz","s_uz","s_sz","l_sz"), # states
                                   role = c(rep("attribute",7),
                                            rep("data_series",2),
                                            rep("parameter",7),
                                            rep("state",5)),
                                   type = c("integer",rep("numeric",4),rep("list",2),
                                            rep("character",2),
                                            rep("character",7),
                                            rep("numeric",5)),
                                   stringsAsFactors=FALSE),
            channel = data.frame(name= c("id","area","length","flow_dir", # states
                                         "precip","pet", # inputs
                                         "v_ch"), # parameters
                                 role = c(rep("attribute",4),
                                          rep("data_series",2),
                                          rep("parameter",1)),
                                 type = c("integer",rep("numeric",2),"list",
                                          rep("character",2),
                                          rep("character",1)),
                                 stringsAsFactors=FALSE),
            point_inflow = data.frame(name = c("name","id","fraction"),
                                      type=c("character","integer","numeric"),
                                      role = c("data_series",rep("attribute",2)),
                                      stringsAsFactors=FALSE),
            diffuse_inflow = data.frame(name = c("name","id"),
                                        type=c("character","integer"),
                                        role = c("data_series","attribute"),
                                        stringsAsFactors=FALSE),
            gauge = data.frame(name = c("name","id","fraction"),
                               type=c("character","integer","numeric"),
                               role = c("output_label",rep("attribute",2)),
                               stringsAsFactors=FALSE)
        ),
        ## convert the form of the model for internal storage
        ## we presume the model has been checked!!
        digest_model = function(model){
            ## initialise output model format as a list
            ## copy anything that requires no alteration
            out <- list(param=model$param)
            ## store to record the names of the data series required
            data_series <- list(); ds_cnt <- 1;
            
            ## convert into lists
            for(tbl in names(private$model_description)){
                prop <- private$model_description[[tbl]]
                out[[tbl]] <- as.list( model[[tbl]] )
                ## remove names so they don;t propergate
                for(ii in names(out[[tbl]])){
                    out[[tbl]][[ii]] <- unname(out[[tbl]][[ii]])
                }
                ## handle parameters - note name of vector is the parameter name
                for(ii in prop$name[prop$role=="parameter"]){
                    out[[tbl]][[ ii ]] <- model$param[ out[[tbl]][[ii]] ]
                }
                
                ## get input series
                for(ii in prop$name[prop$role=="data_series"]){
                    ## add back in names used in export
                    ## recall names are converted to index when data loaded
                    names(out[[tbl]][[ ii ]]) <- out[[tbl]][[ii]] 
                    data_series[[ds_cnt]] <- unique( out[[tbl]][[ ii ]] )
                    ds_cnt <- ds_cnt + 1
                }
            }

            ## work out the sequences for computing the lateral flux bands these are the index in the hillslope vectors NOT the id
            out$sqnc <- list(sf=list(),sz=list())
            for(ii in names(out$sqnc)){
                bnd <- switch(ii,
                              sf = sapply(model$hillslope$sf_dir,function(x){x$band}),
                              sz = sapply(model$hillslope$sz_dir,function(x){x$band})
                              )
                out$sqnc[[ii]] <- (1:length(model$hillslope$id))[order(bnd)]
            }

            ## reprocess the fractions of the routing so it includes area ratio correctly
            ## initialise vector of areas
            tmp <- rep(NA,max(c(model$hillslope$id,model$channel$id)))
            tmp[model$channel$id] <- model$channel$area
            tmp[model$hillslope$id] <- model$hillslope$area
            out$sf_dir_a <- model$hillslope$sf_dir
            out$sz_dir_a <- model$hillslope$sz_dir
            for(ii in 1:length(out$sf_dir_a)){
                out$sf_dir_a[[ii]]$frc <- model$hillslope$area[ii] * out$sf_dir_a[[ii]]$frc /
                    tmp[ out$sf_dir_a[[ii]]$idx ]
                out$sz_dir_a[[ii]]$frc <- model$hillslope$area[ii] * out$sz_dir_a[[ii]]$frc /
                    tmp[ out$sz_dir_a[[ii]]$idx ]
            }
            rm(tmp)

            ## copy to private
            private$info$data_series <- unique( do.call(c,data_series) )
            private$model <- out
            ## TODO inc in description
            private$model$map <- model$map
            
            invisible( self )
        },
        ## convert the form the internal storage to that input
        ## we presume the model has been checked!!
        reform_model = function(){
            
            ## initialise output model format as a list
            ## include variables that don;t need transformation
            out <- list(param=private$model$param)
            
            ## convert into lists
            for(tbl in names(private$model_description)){
                print(tbl)
                ## required properties
                prop <- private$model_description[[tbl]]

                ## get names of all series
                nm <- names(private$model[[tbl]])
                nm <- split(nm,nm%in%c("sz_dir","sf_dir","flow_dir"))
                out[[tbl]] <- as.data.frame( private$model[[tbl]][nm[["FALSE"]]] ,
                                            stringsAsFactors=FALSE)
                for(ii in nm[["TRUE"]]){
                    ##print(ii)
                    out[[tbl]][,ii] <- private$model[[tbl]][ii]
                }
                
                
                ## handle parameters - note name of vector is the parameter name
                for(ii in prop$name[prop$role %in% c("parameter","data_series")]){
                    out[[tbl]][,ii] <- names( private$model[[tbl]][[ii]] )
                }
            }

            ## TODO inc in description
            out$map <- private$model$map
            return(out)
        },
        ## this code checks the model
        check_model = function(model, use_states, verbose, delta=1e-13){
            
            ## check all components of the model exist
            components <- names(private$model_description)
            idx <- components %in% names(model)
            if( !all(idx) ){
                stop(paste("Missing componets:",paste(components[!idx],collapse=",")))
            }
            
            ## check components that should be data.frames of given structure
    
            ## check the HRU table properties
            req_names <- list(output_names = list(),
                              parameter = list(),
                              data_series = list())
            for(ii in setdiff(components,"param")){
                ## what should the properties of each column be
                prop <- private$model_description[[ii]]
                if(!use_states){
                    prop <- prop[ !(prop$role=="state"), ]
                }
                                
                if(!is.data.frame(model[[ii]])){
                    stop(paste("Table",ii,"should be a data.frame"))
                }
        
                idx <- prop$name %in% names(model[[ii]])
                
                if( !all( idx ) ){# check it has required columns
                    stop( paste("Table",ii,"is missing columns:",
                                paste(prop$name[!idx],collapse=",")) )
                }
                
                ## check data types               
                tmp <- sapply(model[[ii]],class) # types of the columns
                idx <- tmp[ prop$name ] != prop$type
                if( any( idx ) ){
                    stop( paste("Incorrect types in table",ii,"columns:",
                                paste(prop$name[idx],collapse=",")) )
                }
                
                ## take the required names
                for(jj in names(req_names)){
                    tmp <- prop$name[prop$role==jj]
                    req_names[[jj]][[ii]] <- unlist(model[[ii]][,tmp])
                }
            }
            
            ## unpack the required names to vectors
            for(jj in names(req_names)){
                req_names[[jj]] <- do.call(c,req_names[[jj]])
            }
            
            
            ## parameter vector should be named numeric vector and contain all required names
            if( !all(is.vector(model$param), is.numeric(model$param)) ){
                stop("param should be a numeric vector")
            }
            if( length(unique(names(model$param))) != length(model$param) ){
                stop("All values in param should have a unique name")
            }
            idx  <- req_names$parameter %in% names(model$param)
            if(!all(idx)){
                stop(paste("The following parameters are not specified:",
                           paste(req_names[!idx],collapse=",")))
            }
            idx  <- names(model$param) %in% req_names$parameter
            if(!all(idx)){
                stop(paste("The following parameters are not used:",
                           paste(names(model$param)[!idx],collapse=",")))
            }
            
            ## check all output series have unique names
            if( length(req_names$output_names) != length(unique(req_names$output_names)) ){
                stop("All output series should have a unique name")
            }
            
            ## checks on hillslope and channel HSU ids
            all_hsu <- c(model$hillslope$id,model$channel$id)
            if( length(all_hsu) != length(unique(all_hsu)) ){
                stop("HSU id values should be unique") }
            if( !all(is.finite(all_hsu)) ){ stop("HSU id values should be finite") }
            if( !all(range(all_hsu)==c(1,length(all_hsu))) ){
                stop("HSU id's should be numbered consecuativly from 1")
            }
            
            ## all points_inflows and gauges should be on a channel
            ## with fractions between 0 & 1
            for(jj in c("gauge","point_inflow")){
                if(nrow(model[[jj]]) == 0){next}
                idx <- (model[[jj]]$id %in% model[['channel']]$id) &
                    (model[[jj]]$fraction >= 0) &
                    (model[[jj]]$fraction <= 1)
                if( any(!idx) ){
                    stop(paste("The following", jj , "are incorrectly specified:",
                               paste(model[[jj]]$name[!idx],collapse=" ")))
                }
            }
            
            ## all diffuse inflows should be to channels
            if(nrow(model[["diffuse_inflow"]]) > 0){
                if( any(!(model[[jj]]$id %in% model[['channel']]$id)) ){
                    stop(paste("The following diffuse_inputs are incorrectly specified:",
                               paste(model[["diffuse_input"]]$name[!idx],collapse=" ")))
                }
            }
            
            ## checks on redistribution
            ## TODO ad check that going down band?
            ## TODO add check on bound parameter
            fcheck <- function(x){
                all(x$idx %in% all_hsu) & (abs(sum(x$frc)-1) < delta)
            }
            idx <- sapply(model$hillslope$sz_dir,fcheck)
            if( any(!idx) ){
                stop(paste("Saturated flow redistribution is not valid for HSUs:",
                           paste(model$hillslope$id[!idx],collapse=" ")))
            }
            idx <- sapply(model$hillslope$sf_dir,fcheck)
            if( any(!idx) ){
                stop(paste("Surface flow redistribution is not valid for HSUs:",
                           paste(model$hillslope$id[!idx],collapse=" ")))
            }
            
            idx <- sapply(model$channel$flow_dir,function(x){is.null(x) | fcheck(x)})
            if( any(!idx) ){
                stop(paste("Channel flow redistribution is not valid for HSUs:",
                           paste(model$channel$id[!idx],collapse=" ")))
            }
            
            ## specific checks on channel network connectivity - used in channel simulation
            chn_con <- lapply(model$channel$flow_dir,function(x){x$idx})
            
            if( any(sapply(chn_con,length)>1) ){
                stop("Only channels routing to single HSUs are supported")
            }
            is_outlet <- sapply(chn_con,is.null) # identify outlets
            if( !all(do.call(c,chn_con) %in% model$channel$id) ){
                stop("Channels routing to non channel HSUs, set next_id to NA to represent an outflow")
            }
            
            
            to_outlet <- is_outlet
            ## loop channels at top of network
            for(ii in setdiff(model$channel$id,do.call(c,chn_con))){
                ## set up a record of place in search down tree
                in_search <- rep(FALSE,length(model$channel$id))
                jj <- which(model$channel$id==ii)
                while( !in_search[jj] & # fails if loop
                       !to_outlet[jj] ){ # fails at outlet
                           in_search[jj] <- TRUE
                           jj <- which(model$channel$id==chn_con[[jj]])
                       }
                if(to_outlet[jj]){
                    to_outlet[in_search] <- TRUE
                }
            }
            if( any(!to_outlet) ){
                stop(paste("The following channels do not drain to an outlet:",
                           paste(model$channel$id[!to_outlet],collapse=" ")))
            }
            
            ## verbose printing of head and tail channels
            if(verbose){
                ## print out head channels
                message(paste("The head channels are:",
                              paste(setdiff(model$channel$id,chn_con),
                                    collapse=", "),
                              sep="\n"))
                ## print out tail channels
                message(paste("The channels with outfalls:",
                              paste(model$channel$id[is.na(chn_con)],
                                    collapse=", "),
                              sep="\n"))
            }

            ## TODO add checks to map
            
            ## if here we have passed all tests then return
            invisible( self )
            
        },
        
        ## check and add obsservations
        check_obs = function(obs){
            req_series <- private$info$data_series

            ## check types
            if(!is.xts(obs)){ stop("observations should be an xts object") }
            if(!is.vector(req_series) | !all(sapply(req_series,class)=='character') ){ stop("req_series should be a character vector") }
            
            ## check we have all the series needed
            if( !all( req_series %in% names(obs) ) ){
                stop("Missing input series:",setdiff( req_series , names(obs) ))
            }

            ## check constant time step
            tmp <- diff(as.numeric(index(obs)))
            if( !all( tmp == tmp[1] ) ){
                stop("Time steps in data are not unique")
            }
            
            ## check all values are finite
            if( !all(is.finite(obs[,req_series])) ){
                stop("There are non finite values in the required time series")
            }

            ## All checks passed add to private
            private$time_series$obs_data <- as.matrix(obs)
            private$time_series$index <- index(obs)

            ## set the data series flags in the model
            idx <- setNames(1:ncol(obs),names(obs))
            for(tbl in names(private$model_description)){
                ## required properties
                prop <- private$model_description[[tbl]]

                ## handle parameters - note name of vector is the parameter name
                for(ii in prop$name[prop$role == "data_series"]){
                    private$model[[tbl]][[ii]]  <-  idx[ private$model[[tbl]][[ii]] ]
                }
            }
        },
        ## compute the simulation timestep
        comp_ts = function(sub_step=NULL){

            ## TODO move or replicate check in simulation call
            if( (!is.null(sub_step) & !is.numeric(sub_step)) | length(sub_step)>1 ){ stop("sub_step should be a single numeric value or NULL") }
            
            ## work out time steps for use in simulation
            ts <- list()
            ts$step <- diff(as.numeric(private$time_series$index[1:2])) # seconds
            if(is.null(sub_step)){sub_step <- ts$step}
            ts$n_sub_step <- max(1,floor(ts$step/sub_step)) # dimensionless
            ts$sub_step <- ts$step / ts$n_sub_step
            private$info$ts <- ts
        },
        ## ###########################################
        ## Initialise the states
        init_hs = function(initial_recharge){
            ## take local copy of hillslope
            hillslope <- private$model$hillslope
            ## take local copy of the area scaled routing of saturated zone
            sz_dir <- private$model$sz_dir_a
            ## compute the timestep
            ts <- private$comp_ts(NULL)
            
            ## maximum lateral flow from saturated zone per unit area
            beta <- atan(hillslope$s_bar)
            l_szmax <- exp( hillslope$ln_t0 )*sin(beta) / hillslope$delta_x

            ## initialise the surface storage
            hillslope$s_sf <- rep(0,length(hillslope$id))
            
            ## initialise the root zone
            hillslope$s_rz <- pmax( pmin( hillslope$s_rz0, 1) ,0 ) * hillslope$s_rzmax

            ## take recharge to be average inflow rate to saturated zone and solve for
            ## steady state
            bq_uz_sz <- initial_recharge
            il_sz_in <- rep(0,max(c(private$model$channel$id,
                                    private$model$hillslope$id)))
            il_sz <- rep(0,length(hillslope$id))
            hillslope$s_sz <- hillslope$l_sz <- rep(NA,length(hillslope$id))

            
            for(ii in private$model$sqnc$sz){ ## loop through all HSUs in order
                ## solve for instananeous outlflow

                qbar <- min(l_szmax[ii], il_sz_in[ hillslope$id[ii] ]/ts$sub_step)
                hillslope$l_sz[ii] <- min( l_szmax[ii] , qbar+bq_uz_sz )
                il_sz[ii] <- hillslope$l_sz[ii]*ts$step
                ## pass downslope
                il_sz_in[ sz_dir[[ii]]$idx ] <-
                    il_sz_in[ sz_dir[[ii]]$idx ] + sz_dir[[ii]]$frc*il_sz[ii]
            }
            ## compute the deficit based on flow
            hillslope$s_sz <- pmax(0, hillslope$m*( log(l_szmax) - log(hillslope$l_sz))/cos(beta))

            ## TODO handel flow to surface?

            ## solve for unsaturated zone
            hillslope$s_uz <- hillslope$t_d*bq_uz_sz*hillslope$s_sz
            
            ## put model back into private storage
            private$model$hillslope <- hillslope
            
        },
        ## ###############################
        ## function to perform simulations
        sim_hs = function(mass_check,keep_states,sub_step, use_R){
            
            ## compute time substep
            if( !is.null(sub_step) && !is.finite(sub_step[1]) ){
                stop("sub_step should be a single finite value")
            }
            ts <- private$comp_ts(sub_step)
            
            ## Logical if states to be kept
            ## keep_states <- private$time_series$index %in% keep_states

            ## make local copies of output
            ## can't initialise to NA since this produces copy rather then pointer
            ## in Rcpp C++ code
            channel_inflow <- matrix(-Inf,nrow(private$time_series$obs),
                                     length(private$model$channel$id))
            colnames(channel_inflow) <- private$model$channel$id
            mass_errors <- matrix(-Inf,nrow(private$time_series$obs),6)
            colnames(mass_errors) <- c("initial_state","final_state","p","e_t",
                                       "channel_inflow","error")

            if(! use_R ){
                if(any(keep_states)){
                    stop("States are currently not saved for intermediate timesteps in the C++ code set use_R=TRUE to use the R version")
                }
                ## use the Cpp version
                hs_sim_cpp(private$time_series$obs,
                           channel_inflow,
                           mass_errors,
                           private$model$hillslope,
                           private$model$channel,
                           ts,
                           private$model$sz_dir_a,
                           private$model$sf_dir_a,
                           private$model$sqnc)
            }else{
                ## use the r version with warnings

               
                ## take a local copy of the hillslope part of the model and channel id
                hillslope <- private$model$hillslope
                channel <- private$model$channel[c("id","precip","area")]
                
                ## take local copy of the area scaled routings
                sf_dir <- private$model$sf_dir_a
                sz_dir <- private$model$sz_dir_a
                
                ## take a local copy of observed data
                obs_data <- private$time_series$obs_data
                
                ## initialise the time series outputs
                channel_inflow <- matrix(NA,nrow(obs_data),length(channel$id))
                colnames(channel_inflow) <- channel$id
                state_record <- rep(list(NULL),nrow(obs_data))
                if( mass_check ){
                    mass_errors <- matrix(NA,nrow(obs_data),6)
                    colnames(mass_errors) <- c("initial_state","final_state","p","e_t",
                                               "channel_inflow","error")
                }else{
                    mass_errors <- NULL
                }
                
                ## simple function for solving ODE
                fode <- function(a,b,x0,t){
                    ## b <- pmax(b,1e-10)
                    ebt <- exp(-b*t)
                    kappa <- (1-ebt)/b
                    kappa[b==0] <- t
                    ## kappa <- pmin(t,(1-ebt)/b)
                    ## x <- unname( x0*ebt + (a/b)*(1-ebt) )
                    x <- unname( x0*ebt + a*kappa )
                    return(x)
                }
                
                ## initialise the stores of the lateral flux inflows
                ## stored as [m3/m2] where the area is that of the receiving HSU
                il_sf_in <- rep(NA,max(c(hillslope$id,channel$id)))
                il_sz_in <- rep(NA,max(c(hillslope$id,channel$id)))
                
                ## compute some local constants for the hillslope HSUs
                ## max lateral flow in saturated zone as [m/s]
                ## l_szmax <- exp( hillslope$ln_t0 )*hillslope$s_bar / hillslope$delta_x
                beta <- atan(hillslope$s_bar)
                cosbeta_m <- cos(beta)/hillslope$m
                sinbeta <- sin(beta)
                l_szmax <- exp( hillslope$ln_t0 )*sinbeta / hillslope$delta_x
                rm(beta)
                
                ## constants in surface flow solution
                tmp <- ts$sub_step/hillslope$t_sf
                omega_1 <- exp(-tmp)
                omega_2 <- (1-omega_1)/tmp
                omega_2[tmp==0] <- ts$sub_step
                
                
                ## initialise vertical flux stores
                iq_sf_rz <- rep(NA,length(hillslope$id))
                iq_rz_uz <- rep(NA,length(hillslope$id))
                iq_rz_sf <- rep(NA,length(hillslope$id))
                iq_uz_sz <- rep(NA,length(hillslope$id))
                
                ## initialise storage for tempory variables
                ## input series
                p <- e_p <- rep(NA,length(hillslope$id))
                ## used in surface storage solution
                il_sf <- rep(NA,length(hillslope$id))
                ## used in root zone storage solution
                ts_rz <- rep(NA,length(hillslope$id)) ## intermediate solution of s_rz
                ie_t <- rep(NA,length(hillslope$id)) # actual evapotranspiration vol [m]
                is_sat <- rep(NA,length(hillslope$id)) # logical indicating if saturated
                ## used in unsaturated zone solution
                ts_uz <- rep(NA,length(hillslope$id)) ## intermediate solution of s_uz
                ## used in saturated zone solution
                ts_sz <- rep(NA,length(hillslope$id)) ## intermediate solution of s_sz
                il_sz <- rep(NA,length(hillslope$id)) ## integral of lateral outflow
                
                
                ## start loop of time steps            
                for(it in 1:nrow(obs_data)){
                    
                    ## set the inputs to the hillslope
                    ## set as rate m/s
                    p <- obs_data[it,hillslope$precip]/ts$step
                    e_p <- obs_data[it,hillslope$pet]/ts$step
                    
                    ## initialise channel inflow volume of precip
                    ## This is accumulate as volume [m3/m2] then converted to flow at end
                    channel_inflow[it,] <- obs_data[it,channel$precip]
                
                    ## start mass check
                    if(mass_check){
                        ## initialise with volume stored and precip volume
                        ## initialise e_t to be accumulated
                        mass_errors[it,"initial_state"] <- sum(
                            hillslope$area *
                            (hillslope$s_sf + hillslope$s_rz +
                             hillslope$s_uz - hillslope$s_sz) )
                        mass_errors[it,"p"] <- sum(hillslope$area * p*ts$step) +
                            sum(channel_inflow[it,]*channel$area) ## this is precip to channel
                        mass_errors[it,"e_t"] <- 0
                    }
                    
                    
                    ## loop sub steps
                    for(inner in 1:ts$n_sub_step){
                        
                        ## initialise lateral influxes to HSUs to zero
                        il_sf_in[] <- 0
                        il_sz_in[] <- 0
                        
                        ## Step 1: Distribute any surface storage downslope                  
                        il_sf[] <- 0
                        ## initialise hillslope lateral flow out as volume
                        for(ii in private$model$sqnc$sf){ ## loop through all HSUs in order
                            ## compute new integral of lateral flux
                            il_sf[ii] <- (1-omega_1[ii])*hillslope$s_sf[ii] +
                                (1 - omega_2[ii])*il_sf_in[hillslope$id[ii]]
                            ## pass downslope
                            il_sf_in[ sf_dir[[ii]]$idx ] <-
                                il_sf_in[ sf_dir[[ii]]$idx ]+
                                sf_dir[[ii]]$frc * il_sf[ii]
                        }
                        ## compute new storage
                        hillslope$s_sf <- hillslope$s_sf + il_sf_in[hillslope$id] - il_sf
                        ## compute flow to root zone and correct storage
                        iq_sf_rz <- pmin( hillslope$q_sfmax*ts$sub_step,hillslope$s_sf )
                        hillslope$s_sf <- hillslope$s_sf - iq_sf_rz
                        
                        ## Step 2: solve the root zone for hillslope elements
                        ## solve ODE                    
                        ts_rz <- fode( p + (iq_sf_rz/ts$sub_step),
                                      e_p/hillslope$s_rzmax,
                                      hillslope$s_rz,ts$sub_step )
                        
                        ## work out actual evapotranspiration by mass balance
                        ie_t <- hillslope$s_rz + p*ts$sub_step + iq_sf_rz - ts_rz
                        
                        if(mass_check){
                            mass_errors[it,'e_t'] <- mass_errors[it,'e_t'] +
                                sum(ie_t*hillslope$area)
                        }
                        
                        ## new storage value
                        hillslope$s_rz <- pmin(ts_rz,hillslope$s_rzmax)
                        
                        ## split root zone flow
                        iq_rz_uz <- ts_rz - hillslope$s_rz ## presume goes to unsaturated zone
                        is_sat <- hillslope$s_sz <= 0
                        iq_rz_sf <- iq_rz_uz*is_sat
                        iq_rz_uz <- iq_rz_uz*!is_sat
                        
                        ## Step 3: Unsaturated zone
                        ## solve ODE
                        ts_uz <- fode( iq_rz_uz/ts$sub_step,
                                      1 / (hillslope$t_d * hillslope$s_sz),
                                      hillslope$s_uz,ts$sub_step )
                        ## work out outflow
                        iq_uz_sz <- hillslope$s_uz + iq_rz_uz - ts_uz
                        hillslope$s_uz <- ts_uz
                        
                        ## Step 4: Solve saturated zone
                        ## this is omega=theta=1 solution with
                        ## explicit velocity and average inflow                    
                        
                        il_sz <- hillslope$l_sz ## initialise integral calc
                        bq_uz_sz <- iq_uz_sz / ts$sub_step ## flow for uz as rate allowing for angle
                        lbq_uz_sz <- bq_uz_sz*sinbeta
                        
                        ## loop HSUs                    
                        for(ii in private$model$sqnc$sz){## loop through all HSUs in order
                            
                            ## inflow as rate
                            l_szin <- min( il_sz_in[hillslope$id[ii]] /ts$sub_step,
                                          l_szmax[ii] )
                            
                            ## compute flow for velocity calculation
                            lbar <- (2/3)*(l_szin+lbq_uz_sz[ii]) +
                                hillslope$l_sz[ii]/3
                            lbar <- min(lbar,l_szmax[ii])
                            
                            ## compute lambda
                            ## using  c = l*Delta_x*cos(beta)/m
                            ## lambda = c*Delta_t/Delta_x
                            lambda <- lbar*ts$sub_step*cosbeta_m[ii]
                            if(lambda==0){lp <- 0}else{lp <- 1} # lambda=0 implies no flow!
                            
                            ## solve for estimate of outflow
                            tl_sz <- (lp*hillslope$l_sz[ii] + lambda*(l_szin + bq_uz_sz[ii]))/
                                (1+lambda)
                            
                            hillslope$l_sz[ii] <- min( l_szmax[ii],tl_sz )
                            ## integral of outflow
                            il_sz[ii] <- (ts$sub_step/2)*(il_sz[ii] + hillslope$l_sz[ii])
                            ## pass downslope
                            il_sz_in[ sz_dir[[ii]]$idx ] <-
                                il_sz_in[ sz_dir[[ii]]$idx ] +
                                sz_dir[[ii]]$frc*il_sz[ii]
                        }
                        
                        ## update volumes in hillslope
                        ts_sz <- hillslope$s_sz + il_sz - il_sz_in[hillslope$id] - iq_uz_sz
                        hillslope$s_sz <- pmax(0,ts_sz)
                        ## compute the flux to the surface
                        iq_sz_sf <- hillslope$s_sz - ts_sz
                        
                        ## step 5 - correct the stores for saturation flows
                        is_sat <- hillslope$s_sz <= 0
                        iq_uz_sf <- hillslope$s_uz*is_sat
                        hillslope$s_uz <- hillslope$s_uz - iq_uz_sf
                        hillslope$s_sf <- hillslope$s_sf +
                            iq_rz_sf + iq_sz_sf + iq_uz_sf
                        
                        ## update volume of flow to channel
                        channel_inflow[it,] <- channel_inflow[it,] +
                            il_sf_in[channel$id] + il_sz_in[channel$id]
                        
                        
                    } ## end of sub_step loop
                    
                    
                    ## complete mass balance check
                    if( mass_check ){
                        mass_errors[it,"final_state"] <- sum(
                            hillslope$area *
                            (hillslope$s_sf + hillslope$s_rz +
                             hillslope$s_uz - hillslope$s_sz) )
                        mass_errors[it,"channel_inflow"] <- sum(channel_inflow[it,]*
                                                                channel$area )
                        ## work out the error
                        mass_errors[it,"error"] <-
                            mass_errors[it,"initial_state"] + mass_errors[it,"p"] -
                            mass_errors[it,"final_state"] - mass_errors[it,"e_t"] -
                            mass_errors[it,"channel_inflow"]
                        
                        if( abs(mass_errors[it,"error"]) > 1e-6  ){
                            browser()
                            cat("Iteration ",it," large mass error: ",
                                mass_errors[it,"error"],"\n")
                        }
                    }
                    
                    ## copy states if requires
                    if( keep_states[it] ){
                        state_record[[it]] <- private$extract_states(hillslope,"hillslope")
                    }
                    
                    ## convert channel inflow to [m3/s]
                    channel_inflow[it,] <- channel_inflow[it,]*channel$area/ts$step
                    
                    
                } ## end of timestep loop
                
                
                ## copy model with revised states back
                private$model$hillslope <- hillslope
                private$time_series$state_record <- state_record
            }
            
            ## copy to storage
            private$time_series$channel_inflow <- channel_inflow
            private$time_series$mass_errors <- mass_errors
            
        },
        ## convert a data frame to a storage list
        extract_states = function(obj,type=names(private$model_description)){
            type <- match.arg(type)

            stt <- private$model_description[[type]]
            stt <- c("id",stt$name[stt$role=="state"])
            out <- as.data.frame( obj[stt], stringsAsFactors=FALSE )
            return(out)
        },
        ## #############################
        init_ch = function(){
            
            channel <- private$model$channel
            gauge <- private$model$gauge
            point_inflow <- private$model$point_inflow
            
            ## check each channel has only one down stream neighbour
            ## Done it check_model

            ## check channel HSU id numbers are 1,2,3,....
            
            if( !all(channel$id %in% 1:length(channel$id)) ){
                stop("Channel id should be numbered 1,2,.. with no gaps")
            }
            
            ## get the channels downstream of each id
            chn_con <- sapply(channel$flow_dir,
                              function(x){if(is.null(x)){-99}else{x$idx}})
            chn_con[channel$id] <- unname(chn_con)
            
            ## compute the time to travel down each reach
            reach_time <- unname( channel$length / channel$v_ch )
            reach_time[channel$id] <- unname(reach_time)


            linear_time <- setNames(rep(list(NULL),length(gauge$name)),
                                    gauge$name)
            
            ## Loop gauges
            for(rw in 1:length(gauge$name)){
                time_to_head <- rep(NA,length(channel$id))
                ## add gaguge reach is in
                ii <- gauge$id[rw]
                time_to_head[ii] <- reach_time[ii]*gauge$fraction[rw]
                ## get upstream reaches
                idx <- which(chn_con==ii)
                ## loop upstream
                while(length(idx)>0){
                    idx_list <- list()
                    cnt <- 1
                    for(ii in idx){
                        time_to_head[ii] <- reach_time[ii] + time_to_head[ chn_con[ii] ]
                        idx_list[[cnt]] <- which(chn_con==ii)
                        cnt <- cnt+1
                    }
                    idx <- do.call(c,idx_list)
                }
                ## initialise gauge timeing object
                tmp <- list(diffuse=list(),
                            point=list())

                ## work out for diffuse inputs
                for(ii in which(is.finite(time_to_head))){
                    tmp$diffuse[[paste(ii)]] <- list(head_to_gauge=time_to_head[ii],
                                                     reach_time = reach_time[ii])
                }

                ## work out for points
                if(length(point_inflow$name)>0){
                    for(ii in 1:length(point_inflow$name)){
                        jj <- point_inflow$id[ii]
                        if( is.finite( time_to_head[ jj ] ) ){
                            delta <- time_to_head[jj]* point_inflow$fraction[ii]
                            tmp$point[[ point_inflow$name[ii] ]] <- list(
                                head_to_gauge = time_to_head[jj] - delta,
                                reach_time = 0)
                        }
                    }
                }
                linear_time[[gauge$name[rw]]] <- tmp
            }
            
            private$model$linear_channel <- linear_time
        },
        sim_ch = function(){
            ## initialise the output
            out <- matrix(NA,length(private$time_series$index),
                          length(private$model$linear_channel))
            colnames(out) <- names(private$model$linear_channel)

            ## function to make polynonial and initial conditions
            fpoly <- function(x){
                t2g <- c(x$head_to_gauge, x$head_to_gauge - x$reach_time )
                t2g <- pmax(t2g,0) ## ensure it is 0
                qfrac <- min(1, (t2g[1]-t2g[2])/x$reach_time )# min fixed divide by 0 of points
                ## divide by time step
                t2g <- t2g / private$info$ts$step
                d2g <- floor(t2g) + 1 # limits on steps to have

                ply <- rep(0,d2g[1])
                idx <- d2g[2]:d2g[1]
                ply[idx] <- 1
                if(t2g[1]>t2g[2]){
                    delta <- t2g - d2g
                    delta[1] <- 1-delta[1]
                    ply[d2g] <- ply[d2g] - delta
                }
                return(qfrac*(ply/sum(ply)))
            }
    
            ## Loop gauges
            
            for(id in names(private$model$linear_channel)){

                ## initialise the point - set to 0
                out[,id] <- 0
                
                
                ## loop channel+diffuse upstream
                for(iid in names(private$model$linear_channel[[id]]$diffuse)){
                    ## get time object
                    tt <- private$model$linear_channel[[id]]$diffuse[[iid]]
                    ## compute polynomial
                    ply <- fpoly(tt)
                    npad <- length(ply)-1
                    ## compute input
                    x <- private$time_series$channel_inflow[,iid]
                    ## add diffuse inputs to x
                    nm <- private$model$diffuse_inflow$name[private$model$diffuse_inflow$id==id]
                    x <- x + rowSums(private$time_series$obs[,nm])

                    ## add initial padding to input
                    x <- c(rep(x[1],npad),x)
                    ## apply polynomial
                    q <- filter(x,ply,method="conv",sides=1)
                    if(npad>0){q <- q[-(1:npad)]}
                    out[,id] <- out[,id] + q
                }
                
                ## loop point inputs upstream
                for(iid in names(private$model$linear_channel[[id]]$point)){
                    ## get time object
                    tt <- private$model$linear_channel[[id]]$diffuse[[iid]]
                    ## compute polynomial
                    ply <- fply(tt)
                    npad <- length(ply)-1
                    ## compute input
                    x <- private$time_series$obs[,iid]
                    ##TODO add diffuse inputs to x
                    x <- c(rep(x[1],npad),x)
                    ## apply polynomial
                    q <- filter(x,ply,method="conv",sides=1)
                    if(npad>0){q <- q[-(1:npad)]}
                    out[,id] <- out[,id] + q
                }

            }

            private$time_series$gauge_flow <- out
        }
    )
    )

    
    
