#' R6 Class for Dynamic TOPMODEL
#' @export

## START HERE:
## (i) Need to check importing and exporting a model
## (iii) Need to adapt calls to hillslope C++ to take in inputs as matrices then seperate out internally
## (iv) Impliment second channel routing?

dynatop <- R6::R6Class(
    "dynatop",
    public = list(
        #' @description Creates a dynatop class object from the a list based model description as generated by dynatopGIS.
        #'
        #' @param model a dynamic TOPMODEL list object
        #' @param use_states logical if states should be imported
        #' @param drop_map logical if the map should be dropped
        #' @param verbose if set prints out further information
        #' @param delta error term in checking redistribution sums
        #'
        #' @return invisible(self) suitable for chaining
        #'
        #' @details This function makes some basic consistency checks on a list representing a dynamic TOPMODEL model. The checks performed and basic 'sanity' checks. They do not check for the logic of the parameter values nor the consistncy of states and parameters. Sums of the redistribution matrices are checked to be in the range 1 +/- delta.
        initialize = function(model, use_states=FALSE, verbose=FALSE, delta = 1e-13){
            ## generate model description
            private$generate_model_description(model)
            ## check model will fail if there is an error
            private$check_model(model,use_states,verbose,delta)
            ## convert model here
            private$digest_model(model,use_states)
            invisible(self)
        },
        #' @description Adds observed data to a dynatop object
        #'
        #' @param obs_data an xts object of observed data
        #'
        #' @return invisible(self) suitable for chaining
        #'
        #' @details This function makes some basic consistency checks on the observations to ensure they have uniform timestep and all required series are present.
        add_data = function(obs_data){
            self$clear_data()
            ## check input and get model timestep
            private$check_obs(obs_data)
            private$digest_obs(obs_data)
            invisible(self)
        },
        #' @description Clears all forcing and simulation data except current states
        #'
        #' @return invisible(self) suitable for chaining
        clear_data = function(){
            private$time_series <- list()
            private$info$ts <- list()
        },
        #' @description Initialises a dynatop object in the simpliest way possible.
        #'
        #' @param initial_recharge Initial recharge to the saturated zone in steady state in m/s
        #'
        #' @return invisible(self) suitable for chaining
        initialise = function(initial_recharge){
            
            ## check initial discharge
            if( !is.numeric(initial_recharge) | length(initial_recharge) > 1 | any( initial_recharge < 0 ) ){
                stop("Initial discharge should be a single positive numeric value")
            }
            
            private$init_hs(initial_recharge)
            ##print("returned from init_hs")
            private$init_ch()
            invisible(self)
        },
        #' @description Simulate the hillslope output of a dynatop object
        #' @param keep_states a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept
        #' @param sub_step simulation timestep in seconds, default value of NULL results in data time step
        #'
        #' @details Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
        sim_hillslope = function(keep_states=NULL,sub_step=NULL){

            ## check presence of states
            if( !all(is.finite(private$states$hillslope)) ){
                stop("Model states are either no initialised or have non-finite values")
            }
            
            if( !is.null(sub_step) && !is.finite(sub_step[1]) ){
                stop("sub_step should be a single finite value")
            }
            
            ## check presense of obs
            if( length(private$time_series$index) < 2 ){
                stop("Insufficent data to perform a simulation")
            }
            
            ## check keep_states is valid
            if( length(keep_states)>0 ){
                if( !("POSIXct" %in% class(keep_states)) ){
                    stop("Times for returning states should be POSIXct object")
                }
            }
            keep_states <- keep_states[keep_states %in% private$time_series$index]
                        
            ## simulate
            private$sim_hs(keep_states,sub_step[1])

            invisible(self)
        },
        #' @description Simulate the channel output of a dynatop object
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @return invisible(self) for chaining
        sim_channel=function(mass_check=FALSE){
           
            if(!private$info$can_solve_channel){
                stop("Cannot simulate channel - check connectivity")
            }
            
            if(mass_check){
                ## TODO add a mass check
                warning("Channel mass check not yet implimented")
            }
            ## check presence of channel_inflow
            if( nrow(private$time_series$channel_inflow) !=
                length(private$time_series$index) ){
                stop("Suitable channel_inflow not available")
            }
            if( length(private$time_series$index) < 2 ){
                stop("Insufficent data to perform a simulation")
            }
            ##TODO check initiaalised
           
            private$sim_ch()

            invisible(self)
        },
        #' @description Simulate the hillslope and channel componets of a dynatop object
        #' @param keep_states a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @param sub_step simulation timestep in seconds, default value of NULL results in data time step
        #' @param use_R shoudl the R version of the simulation code be used (default FALSE)
        #'
        #' @details Calls the sim_hillslope and sim_channel in sequence. Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
        #'
        #' @return invisible(self) for chaining
        sim = function(mass_check=FALSE,keep_states=NULL,sub_step=NULL){
            self$sim_hillslope(mass_check,keep_states,sub_step)
            self$sim_channel()
            invisible(self)
        },
        ## ############
        ## Functions for extracting and plotting data
        #' @description Return channel inflow as an xts series
        #' @param total logical if plot total inflow is to be plotted
        get_channel_inflow = function(total=FALSE){
            x <- private$time_series$channel_inflow
            if(total){
                x <- rowSums(x)
            }
            xts::xts(x,
                     order.by=private$time_series$index)
        },
        #' @description Plot the channel inflow
        #' @param total logical if plot total inflow is to be plotted
        plot_channel_inflow = function(total=FALSE){
            x <- self$get_channel_inflow(total)
            plot(x)
        },
        #' @description Return flow at the gauges as an xts series
        #' @param gauge names of gauges to return (default is all gauges)
        get_gauge_flow = function(gauge=colnames(private$time_series$gauge_flow)){           
            gauge <- match.arg(gauge,colnames(private$time_series$gauge_flow),
                               several.ok=TRUE)
            xts::xts(private$time_series$gauge_flow[,gauge,drop=FALSE],
                     order.by=private$time_series$index)
        },
        #' @description Get the flow at gauges
        #' @param gauge names of gauges to return (default is all gauges)
        plot_gauge_flow = function(gauge=names(private$time_series$gauge_flow)){
            plot( self$get_gauge_flow(gauge) )
        },
        #' @description Get the observed data
        get_obs_data = function(){
            xts::xts(private$time_series$obs,
                     order.by=private$time_series$index)
        },
        #' @description Return the model
        get_model = function(){
            private$reform_model()
        },
        #' @description Return the model
        get_mass_errors = function(){
            if( !("mass_balance" %in% names(private$time_series)) ){
                stop("Mass errors are not available")
            }
            xts::xts(private$time_series$mass_balance,
                     order.by=private$time_series$index)
        },
        #' @description Return states
        #' @param record logical TRUE if the record should be returned. Otherwise surrent states returned
        get_states = function(record=FALSE){
            if( record ){
                return( setNames(private$time_series$state_record,
                                 private$time_series$index) )
            }else{
                return( private$unpack$hillslope$states )
            }
       },
       #' @description Plot a current state of the system
       #' @param state the name of the state to be plotted
       #' @param add_channel Logical indicating if the channel should be added to the plot
       plot_state = function(state,add_channel=TRUE){
           
           if( is.null(private$model$map$hillslope) ){
               stop("The model contains no map of HSU locations")
           }
           if( !file.exists(private$model$map$hillslope) ){ stop("The model map file is missing") }
           if( add_channel & !file.exists(private$model$map$channel) ){ warnings("File containing the channel network does not exist") }
           
           if(!(state%in%colnames(private$states$hillslope))){
               stop("Model state does not exist")
           }
           
           if( !("raster" %in% rownames(installed.packages())) ){
               stop( "The raster package is required for plotting the maps of states - please install or add to libPath" )
           }
           
           x <- private$states$hillslope[,state]
           rst <- raster::raster(private$model$map$hillslope)
           rst <- raster::subs(rst, data.frame(as.integer(names(x)),x))
           
           raster::plot( rst)
           if( add_channel & file.exists(private$model$map$channel) ){
               chn <- raster::shapefile(private$model$map$channel)
               raster::plot(chn,add=TRUE)
           }
           
       }
       
    ),
    private = list(
        ## stores of data
        version = "0.2.0.9020",
        unpack = list(), #storage for unpacked states, properties and parameters used in simulation
        time_series = list(),
        info = list(can_sim_channel=FALSE),
        ## decribes a model tables
        ## roles are either
        ## - attribute
        ## - parameter
        ## - data_series
        ## - state
        ## - output_label
        model_description = list(),
        generate_model_description = function(model){
            
            ## check options vector exists
            if(!("options" %in% names(model))){ stop("No options vector for the model") }
            if(!all(c("transmisivity_profile","channel_solver") %in% names(model$options))){
                stop(paste("Expect value of",
                           setdiff(c("transmisivity_profile","channel_solver"),names(model$options)),
                           "in options vector"))
            }
            
            ## match options and check
            transmisivity_profile <- match.arg(model$options["transmisivity_profile"],
                                               c("exponential"))##,"constant","bounded_exponential"))
            channel_solver <- match.arg(model$options["channel_solver"],
                                        c("histogram"))
            
            ## contents of hillslope table - states and parameters might vary with options
            pnms <- c("r_sfmax","s_rzmax","s_rz0","c_sf") # parameter names
            pnms <- switch(transmisivity_profile,
                           "exponential" = c(pnms,"ln_t0","m","t_d"),
                           "bounded_exponential" = c(pnms,"ln_t0","m","t_d","D"))
            snms <- c("s_sf","s_rz","s_uz","s_sz") # state names
            private$model_description$hillslope = data.frame(
                name = c("id","atb_bar","s_bar","area","width", # attributes associated with catchment HSU
                         pnms, # parameter names
                         snms), # states
                role = c(rep("attribute",5),
                         rep("parameter",length(pnms)),
                         rep("state",length(snms))),
                type = c("integer",rep("numeric",4),
                         rep("character",length(pnms)),
                         rep("numeric",length(snms))),
                stringsAsFactors=FALSE)
            ## contents of channel table - note may change depending upon options
            pnms <- switch(channel_solver,
                           "histogram"="v_ch")
            snms <- switch(channel_solver,
                           "histogram"=NULL)
            private$model_description$channel = data.frame(
                name= c("id","area","length", # states
                        pnms, # parameters
                        snms),
                role = c(rep("attribute",3),
                         rep("parameter",length(pnms)),
                         rep("state",length(snms))),
                type = c("integer",rep("numeric",2),
                         rep("character",length(pnms)),
                         rep("character",length(snms))),
                stringsAsFactors=FALSE)
            ## linkages between HSUs
            private$model_description$flow_direction = data.frame(
                name= c("from","to","frc"),
                role = rep("attribute",3),
                type = c(rep("integer",2),"numeric"),
                stringsAsFactors=FALSE)
            ## rainfall inputs
            private$model_description$rainfall_input = data.frame(
                name = c("name","id","frc"),
                type=c("character","integer","numeric"),
                role = c("data_series",rep("attribute",2)),
                stringsAsFactors=FALSE)
            ## pet inputs
            private$model_description$pet_input = data.frame(
                name = c("name","id","frc"),
                type=c("character","integer","numeric"),
                role = c("data_series",rep("attribute",2)),
                stringsAsFactors=FALSE)
            ## point inflow to channels
            private$model_description$point_inflow = data.frame(
                name = c("name","id"),
                type=c("character","integer"),
                role = c("data_series","attribute"),
                stringsAsFactors=FALSE)
            ## point_inflow = data.frame(name = c("name","id","fraction"),
            ##                           type=c("character","integer","numeric"),
            ##                           role = c("data_series",rep("attribute",2)),
            ##                           stringsAsFactors=FALSE),
            ## diffuse inflow to channels
            private$model_description$diffuse_inflow = data.frame(
                name = c("name","id"),
                type=c("character","integer"),
                role = c("data_series","attribute"),
                stringsAsFactors=FALSE)
            ## location of gauges
            private$model_description$gauge = data.frame(
                name = c("name","id"),
                type=c("character","integer"),
                role = c("output_label","attribute"),
                stringsAsFactors=FALSE)
            ## gauge = data.frame(name = c("name","id","fraction"),
            ##                    type=c("character","integer","numeric"),
            ##                    role = c("output_label",rep("attribute",2)),
            ##                    stringsAsFactors=FALSE)
        },
        ## convert the form of the model for internal storage
        ## we presume the model has been checked!!
        digest_model = function(model,use_states){
            ## It is important that variables are sorted by decreasing id
            ## No check is made for this in the C++ code!!
            ## variables appear in the matrices in the order of model_description
            ## it is important the C++ code matches this

            ## Assume everthing is numeric except for id's which are integer

            ## unpack hillslope and channel
            for(ii in c("hillslope","channel")){
                model[[ii]] <-
                    model[[ii]][order(model[[ii]]$id,decreasing=TRUE),] ## sorting
                private$unpack[[ii]] <- list() ## initialise output
                ## attributes & id
                nm <- private$model_description[[ii]]$name[private$model_description[[ii]]$role=="attribute"]
                nm <- setdiff(nm,"id")
                private$unpack[[ii]]$attribute <- data.matrix(model[[ii]][,nm])
                private$unpack[[ii]]$id <- as.integer(model[[ii]]$id)
                ## unpack states
                nm <- private$model_description[[ii]]$name[private$model_description[[ii]]$role=="state"]
                if(use_states){
                    private$unpack[[ii]]$states <- data.matrix(model[[ii]][,nm])
                }else{
                    private$unpack[[ii]]$states <- matrix(as.numeric(NA),nrow(model[[ii]]),length(nm))
                    ## cludge to get them named
                    if(ii=="hillslope"){
                        colnames(private$unpack[[ii]]$states) <- c("s_sf","s_rz","s_uz","s_sz")
                    }
                }
                ## unpack parameters
                nm <- private$model_description[[ii]]$name[private$model_description[[ii]]$role=="parameter"]
                tmp <- matrix(as.numeric(NA),nrow(model[[ii]]),length(nm))
                dimnames(tmp) <- list(model$hillslope$id,nm)
                for(jj in nm){
                    tmp[,jj] <- as.numeric(model$param[ model[[ii]][,jj] ] )
                }
                private$unpack[[ii]]$param <- tmp
                private$unpack[[ii]]$param_str <- model[[ii]][,nm,drop=FALSE]
            }

            ## unpack flow direction
            model$flow_direction <-
                model$flow_direction[order(model$flow_direction$from,decreasing=TRUE),] ## sort
            private$unpack$flow_direction <- list(
                from = as.integer(model$flow_direction$from),
                to = as.integer(model$flow_direction$to),
                frc = as.numeric(model$flow_direction$frc) )

            ## rainfall and pet fractions
            for(ii in c("rainfall_input","pet_input")){
                model[[ii]] <-
                    model[[ii]][order(model[[ii]]$id,decreasing=TRUE),]
                private$unpack[[ii]] <- list(
                    name = as.character(model[[ii]]$name),
                    id = as.integer(model[[ii]]$id ),
                    frc = as.numeric(model[[ii]]$frc) )
            }

            ## channel inflows, gauge locastionsm, parameters etc - just copy..
            for(ii in c("options","diffuse_inflow","point_inflow","gauge","param","map")){
                private$unpack[[ii]] <- model[[ii]]
            }

            ## work out all the required input series
            data_series <- list()
            for(tbl in names(private$model_description)){
                prop <- private$model_description[[tbl]]
                ii <- prop$name[prop$role=="data_series"]
                data_series[[tbl]] <- unique( unlist( model[[tbl]][,ii]) )
            }
            
            private$info$data_series <- unique( do.call(c,data_series) )
          
            invisible( self )
        },
        ## convert the form the internal storage to that input
        ## we presume the model has been checked!!
        reform_model = function(){
            
            ## initialise output model format as a list
            ## include variables that don;t need transformation
            out <- list()
            nm <- names(private$unpack) ## names of all parts of unpacked
            cnm <- c("options","diffuse_inflow","point_inflow","gauge","param","map") ## names of bits that can just be copied
            for(ii in cnm){
                out[[ii]] <- private$unpack[[ii]]
            }
            
            for(ii in setdiff(nm,cnm)){
                #print(ii)
                #if(ii=="channel"){browser()}
                jj <- setdiff(names(private$unpack[[ii]]),c("param","linear_time")) ## trim out matrix of numeric parameter values and other bits that aren't part of the model
                out[[ii]] <- do.call(data.frame,private$unpack[[ii]][jj])
                names(out[[ii]]) <- sapply(strsplit(names(out[[ii]]),"[.]"),
                                           function(x){tail(x,1)})
            }
            
            ## TODO - add description...
            return(out)
        },
        ## this code checks the model
        check_model = function(model, use_states, verbose, delta=1e-13){
            
            ## check all components of the model exist
            components <- names(private$model_description)
            idx <- components %in% names(model)
            if( !all(idx) ){
                stop(paste("Missing componets:",paste(components[!idx],collapse=",")))
            }

            ## check the HRU table properties
            req_names <- list(output_label = list(),
                              parameter = list(),
                              data_series = list())
            for(ii in setdiff(components,"param")){
                ## what should the properties of each column be
                prop <- private$model_description[[ii]]
                if(!use_states){
                    prop <- prop[ !(prop$role=="state"), ]
                }
                                
                if(!is.data.frame(model[[ii]])){
                    stop(paste("Table",ii,"should be a data.frame"))
                }
        
                idx <- prop$name %in% names(model[[ii]])
                
                if( !all( idx ) ){# check it has required columns
                    stop( paste("Table",ii,"is missing columns:",
                                paste(prop$name[!idx],collapse=",")) )
                }
                
                ## check data types               
                tmp <- sapply(model[[ii]],class) # types of the columns
                idx <- tmp[ prop$name ] != prop$type
                if( any( idx ) ){
                    stop( paste("Incorrect types in table",ii,"columns:",
                                paste(prop$name[idx],collapse=",")) )
                }

                ## check all numeric values are finite and positive
                idx <- setNames(rep(FALSE,length(prop$name)),prop$name)
                for(jj in prop$name[prop$type=="numeric"]){
                    if(any(!is.finite(model[[ii]][[jj]])) | !all(model[[ii]][[jj]]>=0)){
                        idx[jj] <- TRUE
                    }
                }
                if(any(idx)){
                    stop("Non-finite or negative values in table ",ii," columns: ",
                         paste(prop$name[idx],collapse=", "))
                }
                
                ## take the required names
                for(jj in names(req_names)){
                    tmp <- prop$name[prop$role==jj]
                    req_names[[jj]][[ii]] <- unlist(model[[ii]][,tmp])
                }
            }
            
            ## unpack the required names to vectors
            for(jj in names(req_names)){
                req_names[[jj]] <- do.call(c,req_names[[jj]])
            }
            
            
            ## parameter vector should be named numeric vector and contain all required names
            if( !all(is.vector(model$param), is.numeric(model$param)) ){
                stop("param should be a numeric vector")
            }
            if( length(unique(names(model$param))) != length(model$param) ){
                stop("All values in param should have a unique name")
            }
            
            idx  <- req_names$parameter %in% names(model$param)
            if(!all(idx)){
                stop(paste("The following parameters are not specified:",
                           paste(req_names[!idx],collapse=",")))
            }
            idx  <- names(model$param) %in% req_names$parameter
            if(!all(idx)){
                stop(paste("The following parameters are not used:",
                           paste(names(model$param)[!idx],collapse=",")))
            }
            
            ## check all output series have unique names
            if( length(req_names$output_names) != length(unique(req_names$output_names)) ){
                stop("All output series should have a unique name")
            }
            
            ## checks on hillslope and channel HSU ids
            all_hsu <- c(model$hillslope$id,model$channel$id)
            if( length(all_hsu) != length(unique(all_hsu)) ){
                stop("HSU id values should be unique") }
            if( !all(is.finite(all_hsu)) ){ stop("HSU id values should be finite") }
            if( !all(range(all_hsu)==c(1,length(all_hsu))) ){
                stop("HSU id's should be numbered consecuativly from 1")
            }
            
            ## all points_inflows and gauges should be on a channel
            ## with fractions between 0 & 1
            for(jj in c("gauge","point_inflow")){
                if(nrow(model[[jj]]) == 0){next}
                idx <- (model[[jj]]$id %in% model[['channel']]$id) &
                    (model[[jj]]$fraction >= 0) &
                    (model[[jj]]$fraction <= 1)
                if( any(!idx) ){
                    stop(paste("The following", jj , "are incorrectly specified:",
                               paste(model[[jj]]$name[!idx],collapse=" ")))
                }
            }
            
            ## all diffuse inflows should be to channels
            if(nrow(model[["diffuse_inflow"]]) > 0){
                if( any(!(model[[jj]]$id %in% model[['channel']]$id)) ){
                    stop(paste("The following diffuse_inputs are incorrectly specified:",
                               paste(model[["diffuse_input"]]$name[!idx],collapse=" ")))
                }
            }
            
            ## checks on flow directions
            if(!all( model$flow_direction$from %in% all_hsu )){
                stop("Flow link for unspecified HSU")
            }
            if(!all( model$flow_direction$to %in% all_hsu )){
                stop("Flow link to unspecified HSU")
            }
            if(!all( model$flow_direction$to < model$flow_direction$from )){
                stop("Flow link going to a HSU with higher id - out of order")
            }
            
            tmp <- tapply(model$flow_direction$frc,model$flow_direction$from,sum)
            tmp_idx <- abs(tmp-1)<delta
            if(!(all(tmp_idx))){
                stop("Flow direction fractions in the flow of HSU id's do not sum to 1: ",
                     paste(names(tmp[!idx]),collapse=", "))
            }

            ## check on rainfall and pet input
            for(ii in c("rainfall_input","pet_input")){
                tmp <- tapply(model[[ii]]$frc,model[[ii]]$id,sum)
                tmp_idx <- abs(tmp-1)<delta
                if(!(all(tmp_idx))){
                    stop(paste(ii,"fractions for the following HSU id's do not sum to 1: "),
                         paste(names(tmp[!idx]),collapse=", "))
                }
                tmp_idx <- all_hsu %in% names(tmp)
                if(!all(tmp_idx)){
                    warning(paste0("The following HSUs do not receive ",ii,": "),
                            paste(all_hsu[!idx],collapse=", "))
                }
                if(!all( model[[ii]]$id %in% all_hsu )){
                    stop(paste(ii,"contains id not in HSU tables"))
                }
            }

            ## specific check on hillslope
            if(!all(model$hillslope$id %in% model$flow_direction$from)){
                stop("Hillslope HSU cannot be an outlet or a sink")
            }
            
            ## specific checks on channel network connectivity
            n_chn_con <- setNames(rep(0,length(model$channel$id)),
                                  model$channel$id)
            tmp <- table(model$flow_direction$from)
            nm <- intersect(paste(model$channel$id),names(tmp))
            n_chn_con[nm] <- tmp[nm]
            
            ## TODO change this to reflect constant celerity solution!!!
            if( any(n_chn_con>1) ){
                warning("Only channel HSUs routing to single channel HSUs are supported",
                        "\n",
                        "Channels HSUs with multiple downstream connections are ids: ",
                        paste(names(n_chn_con[n_chn_con>1]),collapse=", "))
                private$info$can_solve_channel <- FALSE
            }else{
                private$info$can_solve_channel <- TRUE
            }

            ## trim to just links from channels
            cfd <- model$flow_direction[ model$flow_direction$from %in% model$channel$id,]
            if(!all(cfd$to %in% model$channel$id)){
                stop("Channel's must flow to channel's")
            }

            #browser()
            is_outlet <- names(n_chn_con[n_chn_con==0]) # no flow from it so outlet
            to_outlet <- rep(FALSE,nrow(cfd))
            to_outlet[cfd$to %in% is_outlet] <- TRUE
            chng <- TRUE
            while(chng){
                idx <- which( cfd$to %in% cfd$from[to_outlet] )
                chng <- any(to_outlet[idx]==FALSE)
                to_outlet[idx] <- TRUE
            }
            if(!all(to_outlet)){
                stop("Some channels do not reach an outlet")
            }

            ## TODO add checks to map
            tmp <- sapply(model$map,file.exists)
            if(!all(tmp)){
                warning("The following maps are missing:\n",
                         paste(names(tmp[!tmp]),collapse="n"))
            }
            
            ## if here we have passed all tests then return
            invisible( self )
            
        },
        
        ## check and add obsservations
        check_obs = function(obs){
            req_series <- private$info$data_series

            ## check types
            if(!is.xts(obs)){ stop("observations should be an xts object") }
            if(!is.vector(req_series) | !all(sapply(req_series,class)=='character') ){ stop("req_series should be a character vector") }
            
            ## check we have all the series needed
            if( !all( req_series %in% names(obs) ) ){
                stop("Missing input series:",setdiff( req_series , names(obs) ))
            }

            ## check constant time step
            tmp <- diff(as.numeric(index(obs)))
            if( !all( tmp == tmp[1] ) ){
                stop("Time steps in data are not unique")
            }
            
            ## check all values are finite
            if( !all(is.finite(obs[,req_series])) ){
                stop("There are non finite values in the required time series")
            }
        },
        digest_obs = function(obs){
            ## Assumes all checks passed
            private$time_series$obs_data <- as.matrix(obs)
            private$time_series$index <- index(obs)

            ## set up the column vectors for the rainfall and pet
            private$unpack$rainfall_input$col_idx <- as.integer(
                match(private$unpack$rainfall_input$name, colnames(private$time_series$obs)) )
            private$unpack$pet_input$col_idx <- as.integer(
                match(private$unpack$pet_input$name, colnames(private$time_series$obs)) )
        },
        ## compute the simulation timestep
        comp_ts = function(sub_step=NULL){
            ## work out time steps for use in simulation
            ts <- list()
            ts$step <- diff(as.numeric(private$time_series$index[1:2])) # seconds
            if(is.null(sub_step)){sub_step <- ts$step}
            ts$n_sub_step <- max(1,floor(ts$step/sub_step)) # dimensionless
            ts$sub_step <- ts$step / ts$n_sub_step
            private$info$ts <- ts
        },
        ## ###########################################
        ## Initialise the states
        init_hs = function(initial_recharge){
            ## TODO check initial recharge
            q0 <- rep(as.numeric(initial_recharge),length(private$unpack$hillslope$id))
            dt_exp_init(as.integer(private$unpack$hillslope$id-1),
                        private$unpack$hillslope$states,
                        private$unpack$hillslope$attr,
                        private$unpack$hillslope$param,
                        private$unpack$channel$id - 1,
                        private$unpack$flow_direction$from - 1,
                        private$unpack$flow_direction$to - 1,
                        private$unpack$flow_direction$frc,
                        q0 )

        },
        ## ###############################
        ## function to perform simulations
        sim_hs = function(keep_states,sub_step){
            
            ## compute time substep
            if( !is.null(sub_step) && !is.finite(sub_step[1]) ){
                stop("sub_step should be a single finite value")
            }
            ts <- private$comp_ts(sub_step)

            ## check the Courant Numbers
            Dx <- private$unpack$hillslope$attribute[,"width"] / private$unpack$hillslope$attribute[,"area"]
            ## check surface courant
            Dx <- private$unpack$hillslope$attribute[,"width"] / private$unpack$hillslope$attribute[,"area"]
            tmp <- private$unpack$hillslope$param[,"c_sf"]*ts$sub_step/Dx
            if( any(tmp>0.7) ){
                warning("Courant number for surface celocity is over 0.7\n",
                        "Suggest maximum sub step is: ",
                        floor( min( 0.7*Dx/private$unpack$hillslope$param[,"c_sf"] )),"seconds")
            }
            ## check saturated zone courant
            tmp <- (exp(private$unpack$hillslope$param[,"ln_t0"])*
                    sin(2*atan(private$unpack$hillslope$attribute[,"s_bar"]))) /
                (2*private$unpack$hillslope$param[,"m"]) ## maximum saturated zone velocity
            if( any((tmp*(ts$sub_step/Dx))>0.7) ){
                warning("Courant number for saturated zone celocity is over 0.7\n",
                        "Suggest maximum sub step is: ",
                        floor( min( 0.7*Dx/tmp) ),"seconds")
            }
            rm(tmp,Dx)

            ## Logical if states to be kept and store
            keep_states <- private$time_series$index %in% keep_states
            if(any(keep_states)){
                private$time_series$state_record <- rep(list(as.data.frame(NULL)),length(private$time_series$index))
            }else{
                private$time_series$state_record <- list()
            }

            ## Initialise the mass error store
            private$time_series$mass_balance <- matrix(as.numeric(NA),nrow(private$time_series$obs),4)
            colnames(private$time_series$mass_balance) <-
                c("initial_state","e_t","p","channel_inflow")

            ## make local copy of channel_inflow
            private$time_series$channel_inflow <- matrix(as.numeric(NA),
                                                         nrow(private$time_series$obs),
                                                         length(private$unpack$channel$id))
            colnames(private$time_series$channel_inflow) <- private$unpack$channel$id
            
            dt_exp_implicit(
                private$unpack$hillslope$id-1,
                private$unpack$hillslope$states,
                private$unpack$hillslope$attribute,
                private$unpack$hillslope$param,
                private$unpack$channel$id-1,
                private$unpack$channel$attribute,
                private$unpack$flow_direction$from -1 ,
                private$unpack$flow_direction$to -1 ,
                private$unpack$flow_direction$frc,
                private$unpack$rainfall_input$col_idx - 1,
                private$unpack$rainfall_input$id - 1,
                private$unpack$rainfall_input$frc,
                private$unpack$pet_input$col_idx - 1,
                private$unpack$pet_input$id - 1,
                private$unpack$pet_input$frc,
                private$time_series$obs,
                private$time_series$channel_inflow,
                private$time_series$mass_balance,
                as.logical( keep_states ),
                private$time_series$state_record,
                ts$step,
                ts$n_sub_step
            )
            
        },
        ## #############################
        init_ch = function(){
            #browser()
            channel <- private$unpack$channel
            gauge <- private$unpack$gauge
            point_inflow <- private$unpack$point_inflow
            
            ## get the channels upstream of each id
            chn_con <- lapply(channel$id,
                              function(x){
                                  ## work out links going to reach from channels
                                  idx <- (private$unpack$flow_direction$to==x) &
                                      (private$unpack$flow_direction$from %in% channel$id)
                                  ## limit to only channels
                                  return( paste(private$unpack$flow_direction$from[idx]) )
                              }
                              )
            names(chn_con) <- paste(channel$id)
            
            
            ## compute the time to travel down each reach
            reach_time <- setNames( channel$attribute[,"length"] / channel$param[,"v_ch"], #private$model$param[channel$v_ch],
                                   channel$id )

            ## storage for output
            linear_time <- setNames(rep(list(NULL),length(gauge$name)),
                                    gauge$name)
            
            ## Loop gauges
            for(gnm in 1:length(gauge$name)){
                ## initialise diffuse input matrix
                df <- matrix(as.numeric(NA),length(channel$id),2)
                colnames(df) <- c("min_time","max_time")
                rownames(df) <- channel$id
                ## start with location of the gauge
                idx <- paste(gauge$id[gnm])
                df[idx,"min_time"] <- 0
                while(length(idx)>0){
                    ii <- idx[1] ## current reach
                    df[ii,"max_time"] <- df[ii,"min_time"] + reach_time[ii] ## work out max time
                    jdx <- chn_con[[ii]] ## get upstream reaches
                    df[jdx,"min_time"] <- df[ii,"max_time"] ## set min time to max time of downstream
                    idx <- c(idx[-1],jdx)
                }

                ## initialise the point inflow matrix
                ii <- paste(point_inflow$id) ## find id of reach
                pnt <- df[ii,] ## copy rows of df table
                pnt[,"min_time"] <- pnt[,"max_time"] # since point inflow at head of reach
                rownames(pnt) <- point_inflow$name ## rename

                linear_time[[gnm]] <- list(diffuse=df,point=pnt)
            }
            
            ##     colnames(pnt)
                             
            ##         ii <- as.integer(iis)
                    
            ##     time_to_head <- rep(NA,length(channel$id))
            ##     ## add gaguge reach is in
            ##     ii <- gauge$id[rw]
            ##     time_to_head[ii] <- reach_time[ii]*gauge$fraction[rw]
            ##     ## get upstream reaches
            ##     idx <- which(chn_con==ii)
            ##     ## loop upstream
            ##     while(length(idx)>0){
            ##         idx_list <- list()
            ##         cnt <- 1
            ##         for(ii in idx){
            ##             time_to_head[ii] <- reach_time[ii] + time_to_head[ chn_con[ii] ]
            ##             idx_list[[cnt]] <- which(chn_con==ii)
            ##             cnt <- cnt+1
            ##         }
            ##         idx <- do.call(c,idx_list)
            ##     }
            ##     ## initialise gauge timeing object
            ##     tmp <- list(diffuse=list(),
            ##                 point=list())

            ##     ## work out for diffuse inputs
            ##     for(ii in which(is.finite(time_to_head))){
            ##         tmp$diffuse[[paste(ii)]] <- list(head_to_gauge=time_to_head[ii],
            ##                                          reach_time = reach_time[ii])
            ##     }

            ##     ## work out for points
            ##     if(length(point_inflow$name)>0){
            ##         for(ii in 1:length(point_inflow$name)){
            ##             jj <- point_inflow$id[ii]
            ##             if( is.finite( time_to_head[ jj ] ) ){
            ##                 delta <- time_to_head[jj]* point_inflow$fraction[ii]
            ##                 tmp$point[[ point_inflow$name[ii] ]] <- list(
            ##                     head_to_gauge = time_to_head[jj] - delta,
            ##                     reach_time = 0)
            ##             }
            ##         }
            ##     }
            ##     linear_time[[gauge$name[rw]]] <- tmp
            ## }
            
            private$unpack$channel$linear_time <- linear_time
        },
        sim_ch = function(){
            
            ## initialise the output
            out <- matrix(NA,length(private$time_series$index),
                          length(private$states$channel$linear_time))
            colnames(out) <- names(private$states$channel$linear_time)
            

            ## function to make polynonial representing time delay histogram
            fpoly <- function(x){
                if( x["min_time"] == x["max_time"] ){
                    ## point input
                    ms <- floor(x["max_time"]/private$info$ts$step)+1
                    ply <- rep(0,ms)
                    ply[ms] <- 1
                }else{
                    ms <- ceiling(x["max_time"]/private$info$ts$step)
                    #ply <- rep(NA,ms)
                    fnsh <- (1:ms)*private$info$ts$step
                    strt <- fnsh - private$info$ts$step
                    strt <- pmax(strt,x["min_time"])
                    fnsh <- pmin(fnsh,x["max_time"])
                    ply <- pmax(0,fnsh-strt)
                }
                return(ply/sum(ply))
            
            }
    ## fpoly <- function(x){
    ##             if( x$reach_time == 0 ){
    ##                 ## point input
    ##                 ms <- floor(x$head_to_gauge/private$info$ts$step)+1
    ##                 ply <- rep(0,ms)
    ##                 ply[ms] <- 1
    ##             }else{
    ##                 ms <- ceiling(x$head_to_gauge/private$info$ts$step)
    ##                 ply <- (0:ms)*private$info$ts$step
    ##                 ply[ply<=x$head_to_gauge - x$reach_time] <- x$head_to_gauge - x$reach_time
    ##                 ply[ply>x$head_to_gauge] <- x$head_to_gauge
    ##                 ply <- diff(ply)
    ##                 ply <- ply/x$reach_time 
    ##             }
    ##             return(ply)
    ##         }
            ## Loop gauges
            
            for(gnm in names(private$states$channel$linear_time)){

                ## initialise the point - set to 0
                out[,gnm] <- 0

                ## diffuse inputs
                df <- private$states$channel$linear_time[[gnm]]$diffuse
                df <- df[is.finite(df[,"frc"]),]

                for(ii in rownames(df)){
                    ply <- fpoly(df[ii,])
                    ## compute input
                    x <- private$time_series$channel_inflow[,ii]
                    ## add diffuse inputs to x
                    idx <- paste(private$model$diffuse_inflow$id)==ii
                    nm <- private$model$diffuse_inflow$name[idx]
                    x <- x + rowSums(private$time_series$obs[,nm])
                    ## pas and filter
                    np <- length(ply)-1
                    x <- c(rep(x[1],np),x)
                    q <- filter(x,ply,method="conv",sides=1)
                    if(np>0){q <- q[-(1:np)]}
                    out[,gnm] <- out[,gnm] + q
                }

                ## handle point inputs
                pnt <- private$states$channel$linear_time[[gnm]]$point
                pnt <- pnt[is.finite(pnt[,"frc"]),]
                ## loop point inputs upstream
                for(ii in rownames(pnt)){
                    ply <- fpoly(pnt[ii,])
                    np <- length(ply)-1
                    ## compute input
                    x <- private$time_series$obs[,ii]
                    x <- c(rep(x[1],np),x)
                    ## apply polynomial
                    q <- filter(x,ply,method="conv",sides=1)
                    if(np>0){q <- q[-(1:np)]}
                    out[,gnm] <- out[,gnm] + q
                }
            }
            ## for(id in names(private$states$channel$linear_time)){

            ##     ## initialise the point - set to 0
            ##     out[,id] <- 0
                
                
            ##     ## loop channel+diffuse upstream
            ##     for(iid in names(private$states$channel$linear_time[[id]]$diffuse)){
            ##         ## get time object
            ##         tt <- private$states$channel$linear_time[[id]]$diffuse[[iid]]
            ##         ## compute polynomial
            ##         ply <- fpoly(tt)
            ##         npad <- length(ply)-1
            ##         ## compute input
            ##         x <- private$time_series$channel_inflow[,iid]
            ##         ## add diffuse inputs to x
            ##         nm <- private$model$diffuse_inflow$name[private$model$diffuse_inflow$id==id]
            ##         x <- x + rowSums(private$time_series$obs[,nm])

            ##         ## add initial padding to input
            ##         x <- c(rep(x[1],npad),x)
            ##         ## apply polynomial
            ##         q <- filter(x,ply,method="conv",sides=1)
            ##         if(npad>0){q <- q[-(1:npad)]}
            ##         out[,id] <- out[,id] + q
            ##     }
                
            ##     ## loop point inputs upstream
            ##     for(iid in names(private$states$channel$linear_time[[id]]$point)){
            ##         ## get time object
            ##         tt <- private$channel$states$linear_time[[id]]$diffuse[[iid]]
            ##         ## compute polynomial
            ##         ply <- fply(tt)
            ##         npad <- length(ply)-1
            ##         ## compute input
            ##         x <- private$time_series$obs[,iid]
            ##         ##TODO add diffuse inputs to x
            ##         x <- c(rep(x[1],npad),x)
            ##         ## apply polynomial
            ##         q <- filter(x,ply,method="conv",sides=1)
            ##         if(npad>0){q <- q[-(1:npad)]}
            ##         out[,id] <- out[,id] + q
            ##     }

            ## }

            private$time_series$gauge_flow <- out
        }
    )
    )

    
    
