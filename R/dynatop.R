#' R6 Class for Dynamic TOPMODEL
#' @export

dynatop <- R6::R6Class(
    "dynatop",
    public = list(
        #' @description Creates a dynatop class object from the a list based model description as generated by dynatopGIS.
        #'
        #' @param model a dynamic TOPMODEL list object
        #' @param use_states logical if states should be imported
        #' @param drop_map logical if the map should be dropped
        #' @param verbose if set prints out further information
        #' @param delta error term in checking redistribution sums
        #'
        #' @return invisible(self) suitable for chaining
        #'
        #' @details This function makes some basic consistency checks on a list representing a dynamic TOPMODEL model. The checks performed and basic 'sanity' checks. They do not check for the logic of the parameter values nor the consistncy of states and parameters. Sums of the redistribution matrices are checked to be in the range 1 +/- delta.
        initialize = function(model, use_states=FALSE, drop_map=FALSE, verbose=FALSE, delta = 1e-13){
            ## check model will fail if there is an error
            private$check_model(model,use_states,verbose,delta)
            ## convert model here
            private$digest_model(model,use_states,drop_map)
            invisible(self)
        },
        #' @description Adds observed data to a dynatop object
        #'
        #' @param obs_data an xts object of observed data
        #'
        #' @return invisible(self) suitable for chaining
        #'
        #' @details This function makes some basic consistency checks on the observations to ensure they have uniform timestep and all required series are present.
        add_data = function(obs_data){
            self$clear_data()
            ## check input and get model timestep
            private$check_obs(obs_data)
            private$digest_obs(obs_data)
            invisible(self)
        },
        #' @description Clears all forcing and simulation data except current states
        #'
        #' @return invisible(self) suitable for chaining
        clear_data = function(){
            private$time_series <- list()
            private$info$ts <- list()
        },
        #' @description Initialises a dynatop object in the simpliest way possible.
        #'
        #' @param initial_recharge Initial recharge to the saturated zone in steady state in m/s
        #'
        #' @return invisible(self) suitable for chaining
        initialise = function(initial_recharge){
            
            ## check initial discharge
            if( !is.numeric(initial_recharge) | length(initial_recharge) > 1 | any( initial_recharge < 0 ) ){
                stop("Initial discharge should be a single positive numeric value")
            }
            
            private$init_hs(initial_recharge)
            ##print("returned from init_hs")
            private$init_ch()
            invisible(self)
        },
        #' @description Simulate the hillslope output of a dynatop object
        #' @param keep_states a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @param sub_step simulation timestep in seconds, default value of NULL results in data time step
        #' @param use_R shoudl the R version of the simulation code be used (default FALSE)
        #'
        #' @details Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
        sim_hillslope = function(mass_check=FALSE,keep_states=NULL,sub_step=NULL,
                                 use_R=FALSE){
            ## check presence of states
            tmp <- private$model_description$hillslope
            if( !all(tmp$name[tmp$role=="state"] %in% names(private$model$hillslope)) ){
                stop("Model states are not initialised")
            }

            if( !is.null(sub_step) && !is.finite(sub_step[1]) ){
                stop("sub_step should be a single finite value")
            }
            
            ## check presense of obs
            if( length(private$time_series$index) < 2 ){
                stop("Insufficent data to perform a simulation")
            }
            
            ## check keep_states is valid
            if( length(keep_states)>0 ){
                if( !("POSIXct" %in% class(keep_states)) ){
                    stop("Times for returning states should be POSIXct object")
                }
            }
            keep_states <- keep_states[keep_states %in% private$time_series$index]
                        
            ## simulate
            private$sim_hs(mass_check,keep_states,sub_step[1],use_R)

            invisible(self)
        },
        #' @description Simulate the channel output of a dynatop object
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @return invisible(self) for chaining
        sim_channel=function(mass_check=FALSE){
            if(mass_check){
                ## TODO add a mass check
                warning("Channel mass check not yet implimented")
            }
            ## check presence of channel_inflow
            if( nrow(private$time_series$channel_inflow) !=
                length(private$time_series$index) ){
                stop("Suitable channel_inflow not available")
            }
            if( length(private$time_series$index) < 2 ){
                stop("Insufficent data to perform a simulation")
            }
            private$sim_ch()

            invisible(self)
        },
        #' @description Simulate the hillslope and channel componets of a dynatop object
        #' @param keep_states a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept
        #' @param mass_check Flag indicating is a record of mass balance errors shuld be kept
        #' @param sub_step simulation timestep in seconds, default value of NULL results in data time step
        #' @param use_R shoudl the R version of the simulation code be used (default FALSE)
        #'
        #' @details Calls the sim_hillslope and sim_channel in sequence. Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
        #'
        #' @return invisible(self) for chaining
        sim = function(mass_check=FALSE,keep_states=NULL,sub_step=NULL,use_R=FALSE){
            self$sim_hillslope(mass_check,keep_states,sub_step,use_R)
            self$sim_channel()
            invisible(self)
        },
        ## ############
        ## Functions for extracting and plotting data
        #' @description Return channel inflow as an xts series
        #' @param total logical if plot total inflow is to be plotted
        get_channel_inflow = function(total=FALSE){
            x <- private$time_series$channel_inflow
            if(total){
                x <- rowSums(x)
            }
            xts::xts(x,
                     order.by=private$time_series$index)
        },
        #' @description Plot the channel inflow
        #' @param total logical if plot total inflow is to be plotted
        plot_channel_inflow = function(total=FALSE){
            x <- self$get_channel_inflow(total)
            plot(x)
        },
        #' @description Return flow at the gauges as an xts series
        #' @param gauge names of gauges to return (default is all gauges)
        get_gauge_flow = function(gauge=colnames(private$time_series$gauge_flow)){
            gauge <- match.arg(gauge,colnames(private$time_series$gauge_flow),
                               several.ok=TRUE)
            xts::xts(private$time_series$gauge_flow[,gauge,drop=FALSE],
                     order.by=private$time_series$index)
        },
        #' @description Get the flow at gauges
        #' @param gauge names of gauges to return (default is all gauges)
        plot_gauge_flow = function(gauge=names(private$time_series$gauge_flow)){
            plot( self$get_gauge_flow(gauge) )
        },
        #' @description Get the observed data
        get_obs_data = function(){
            xts::xts(private$time_series$obs,
                     order.by=private$time_series$index)
        },
        #' @description Return the model
        get_model = function(drop_map=FALSE){
            private$reform_model(as.logical(drop_map))
        },
        #' @description Return the model
        get_mass_errors = function(){
            if( !("mass_errors" %in% names(private$time_series)) ){
                stop("Mass errors are not available")
            }
            xts::xts(private$time_series$mass_errors,
                     order.by=private$time_series$index)
        },
        #' @description Return states
        #' @param record logical TRUE if the record should be returned. Otherwise surrent states returned
        get_states = function(record=FALSE){
            if( record ){
                return( setNames(private$time_series$state_record,
                                 private$time_series$index) )
            }else{
                return( private$extract_states(private$model$hillslope,"hillslope") )
            }            
        },
        #' @description Plot a current state of the system
        #' @param state the name of the state to be plotted
        plot_state = function(state){
            if( is.null(private$model$map) ){
                stop("The model contains no maps of HSU locations")
            }
            
            if( !("raster" %in% rownames(installed.packages())) ){
                stop( "The raster package is required for plotting the maps of states - please install or add to libPath" )
            }
            
            
            
            tmp <- private$model_description$hillslope
            if( !all(tmp$name[tmp$role=="state"] %in% names(private$model$hillslope)) ){
                stop("Model states are not initialised")
            }
            
            state <- match.arg(state,tmp$name[tmp$role=="state"])
            x <- setNames(
                private$extract_states(private$model$hillslope,"hillslope")[,state],
                private$model$hillslope$id)
            x <- x[paste(private$model$map$hillslope)]
            
            raster::plot( raster::raster(crs = private$model$map$scope$crs,
                                 ext = private$model$map$scope$ext,
                                 resolution = private$model$map$scope$res,
                                 vals = x) )
        }
        
    ),
    private = list(
        ## stores of data
        version = 0.12,
        time_series = list(),
        info = list(),
        model = NULL,
        ## decribes a model tables
        ## roles are either
        ## - attribute
        ## - parameter
        ## - data_series
        ## - state
        ## - output_label
        model_description = list(
            hillslope = data.frame(name = c("id","atb_bar","s_bar","area","delta_x","sz_dir","sf_dir", # attributes associated with catchment HSU
                                            "precip","pet", # names of input series
                                            "q_sfmax","s_rzmax","s_rz0","ln_t0","m","t_d","t_sf", # parameter names
                                            "s_sf","s_rz","s_uz","s_sz","l_sz"), # states
                                   role = c(rep("attribute",7),
                                            rep("data_series",2),
                                            rep("parameter",7),
                                            rep("state",5)),
                                   type = c("integer",rep("numeric",4),rep("list",2),
                                            rep("character",2),
                                            rep("character",7),
                                            rep("numeric",5)),
                                   stringsAsFactors=FALSE),
            channel = data.frame(name= c("id","area","length","flow_dir", # states
                                         "precip","pet", # inputs
                                         "v_ch"), # parameters
                                 role = c(rep("attribute",4),
                                          rep("data_series",2),
                                          rep("parameter",1)),
                                 type = c("integer",rep("numeric",2),"list",
                                          rep("character",2),
                                          rep("character",1)),
                                 stringsAsFactors=FALSE),
            point_inflow = data.frame(name = c("name","id","fraction"),
                                      type=c("character","integer","numeric"),
                                      role = c("data_series",rep("attribute",2)),
                                      stringsAsFactors=FALSE),
            diffuse_inflow = data.frame(name = c("name","id"),
                                        type=c("character","integer"),
                                        role = c("data_series","attribute"),
                                        stringsAsFactors=FALSE),
            gauge = data.frame(name = c("name","id","fraction"),
                               type=c("character","integer","numeric"),
                               role = c("output_label",rep("attribute",2)),
                               stringsAsFactors=FALSE)
        ),
        ## convert the form of the model for internal storage
        ## we presume the model has been checked!!
        digest_model = function(model,use_states,drop_map){
            ## create extra rows in data frame which contain the variable values
            ## for when they are passed as strings (e.g. parameters)

            ## store to record the names of the data series required
            data_series <- list(); ds_cnt <- 1;
            
            ## convert into lists
            for(tbl in names(private$model_description)){
                prop <- private$model_description[[tbl]]

                ## handle parameters
                ## create extra _val columns
                ## note names of param vector is the parameter name
                for(ii in prop$name[prop$role=="parameter"]){
                    model[[tbl]][[ paste0(ii,"_value") ]] <- model$param[ model[[tbl]][[ii]] ]
                }
                
                ## get input series
                for(ii in prop$name[prop$role=="data_series"]){
                    data_series[[ds_cnt]] <- unique( model[[tbl]][[ ii ]] )
                    ds_cnt <- ds_cnt + 1
                }

                ## handle states
                for(ii in prop$name[prop$role=="state"]){
                    if(!use_states | !(ii %in% names(model[[tbl]]))){
                        model[[tbl]][[ii]] <- NA
                    }
                }
            }

            ## chage indexs used for flow redistributions
            model$hillslope$id_index <- model$hillslope$id - 1
            model$channel$id_index <- model$channel$id - 1
            model$hillslope$sf_dir_index <- lapply(model$hillslope$sf_dir, function(x){x$idx <- x$idx-1; return(x)})
            model$hillslope$sz_dir_index <- lapply(model$hillslope$sf_dir, function(x){x$idx <- x$idx-1; return(x)})
            
            ## work out the sequences for computing the lateral flux bands
            ## these are the C++ index in the row of the data.frame NOT the id
            model$sqnc <- list(sf=list(),sz=list())
            for(ii in names(model$sqnc)){
                bnd <- switch(ii,
                              sf = sapply(model$hillslope$sf_dir,function(x){x$band}),
                              sz = sapply(model$hillslope$sz_dir,function(x){x$band})
                              )
                model$sqnc[[ii]] <- (1:length(model$hillslope$id))[order(bnd)] -1 ## minus 1 since c++ starts at 0
            }

            ## remove the map if required
            if(drop_map){
                model["map"] <- list(NULL)
            }
                        
            ## copy to private
            private$info$data_series <- unique( do.call(c,data_series) )
            private$model <- model
          
            invisible( self )
        },
        ## convert the form the internal storage to that input
        ## we presume the model has been checked!!
        reform_model = function(drop_map){
            
            ## initialise output model format as a list
            ## include variables that don;t need transformation
            out <- list()
            
            ## convert into lists
            for(tbl in names(private$model_description)){
                print(tbl)
                ## required properties
                prop <- private$model_description[[tbl]]
                out[[tbl]] <- private$model[,prop$name,drop=FALSE]
            }

            ## add map if required
            if(!drop_map){
                out$map <- private$model$map
            }
            ## TODO inc in description
            return(out)
        },
        ## this code checks the model
        check_model = function(model, use_states, verbose, delta=1e-13){
            
            ## check all components of the model exist
            components <- names(private$model_description)
            idx <- components %in% names(model)
            if( !all(idx) ){
                stop(paste("Missing componets:",paste(components[!idx],collapse=",")))
            }
            
            ## check components that should be data.frames of given structure
    
            ## check the HRU table properties
            req_names <- list(output_names = list(),
                              parameter = list(),
                              data_series = list())
            for(ii in setdiff(components,"param")){
                ## what should the properties of each column be
                prop <- private$model_description[[ii]]
                if(!use_states){
                    prop <- prop[ !(prop$role=="state"), ]
                }
                                
                if(!is.data.frame(model[[ii]])){
                    stop(paste("Table",ii,"should be a data.frame"))
                }
        
                idx <- prop$name %in% names(model[[ii]])
                
                if( !all( idx ) ){# check it has required columns
                    stop( paste("Table",ii,"is missing columns:",
                                paste(prop$name[!idx],collapse=",")) )
                }
                
                ## check data types               
                tmp <- sapply(model[[ii]],class) # types of the columns
                idx <- tmp[ prop$name ] != prop$type
                if( any( idx ) ){
                    stop( paste("Incorrect types in table",ii,"columns:",
                                paste(prop$name[idx],collapse=",")) )
                }

                ## check all numeric values are finite and positive
                idx <- setNames(rep(FALSE,length(prop$name)),prop$name)
                for(jj in prop$name[prop$type=="numeric"]){
                    if(any(!is.finite(model[[ii]][[jj]])) | !all(model[[ii]][[jj]]>=0)){
                        idx[jj] <- TRUE
                    }
                }
                if(any(idx)){
                    stop("Non-finite or nagative values in table ",ii," columns: ",
                         paste(prop$name[idx],collapse=", "))
                }
                
                ## take the required names
                for(jj in names(req_names)){
                    tmp <- prop$name[prop$role==jj]
                    req_names[[jj]][[ii]] <- unlist(model[[ii]][,tmp])
                }
            }
            
            ## unpack the required names to vectors
            for(jj in names(req_names)){
                req_names[[jj]] <- do.call(c,req_names[[jj]])
            }
            
            
            ## parameter vector should be named numeric vector and contain all required names
            if( !all(is.vector(model$param), is.numeric(model$param)) ){
                stop("param should be a numeric vector")
            }
            if( length(unique(names(model$param))) != length(model$param) ){
                stop("All values in param should have a unique name")
            }
            idx  <- req_names$parameter %in% names(model$param)
            if(!all(idx)){
                stop(paste("The following parameters are not specified:",
                           paste(req_names[!idx],collapse=",")))
            }
            idx  <- names(model$param) %in% req_names$parameter
            if(!all(idx)){
                stop(paste("The following parameters are not used:",
                           paste(names(model$param)[!idx],collapse=",")))
            }
            
            ## check all output series have unique names
            if( length(req_names$output_names) != length(unique(req_names$output_names)) ){
                stop("All output series should have a unique name")
            }
            
            ## checks on hillslope and channel HSU ids
            all_hsu <- c(model$hillslope$id,model$channel$id)
            if( length(all_hsu) != length(unique(all_hsu)) ){
                stop("HSU id values should be unique") }
            if( !all(is.finite(all_hsu)) ){ stop("HSU id values should be finite") }
            if( !all(range(all_hsu)==c(1,length(all_hsu))) ){
                stop("HSU id's should be numbered consecuativly from 1")
            }
            
            ## all points_inflows and gauges should be on a channel
            ## with fractions between 0 & 1
            for(jj in c("gauge","point_inflow")){
                if(nrow(model[[jj]]) == 0){next}
                idx <- (model[[jj]]$id %in% model[['channel']]$id) &
                    (model[[jj]]$fraction >= 0) &
                    (model[[jj]]$fraction <= 1)
                if( any(!idx) ){
                    stop(paste("The following", jj , "are incorrectly specified:",
                               paste(model[[jj]]$name[!idx],collapse=" ")))
                }
            }
            
            ## all diffuse inflows should be to channels
            if(nrow(model[["diffuse_inflow"]]) > 0){
                if( any(!(model[[jj]]$id %in% model[['channel']]$id)) ){
                    stop(paste("The following diffuse_inputs are incorrectly specified:",
                               paste(model[["diffuse_input"]]$name[!idx],collapse=" ")))
                }
            }
            
            ## checks on redistribution
            ## TODO ad check that going down band?
            ## TODO add check on bound parameter
            
            ## check sf
            ds_hsu <- do.call(c,lapply(model$hillslope$sf_dir,function(x){x$idx}))
            ds_sum <- sapply(model$hillslope$sf_dir,function(x){sum(x$frc)})
            ds_sum <- abs(ds_sum-1)<delta
            if(!all(ds_hsu %in% all_hsu)){
                stop("Surface flow resistirbution is not valid: unexpected recieving HSUs")
            }
            if(!all(ds_sum)){
                stop(paste("Surface flow resistirbution is not valid: Fractions do not sum to one for HSUs",paste(model$hillslope$id[!ds_sum],collapse=", ")))
            }
            
            ## check sz
            ds_hsu <- do.call(c,lapply(model$hillslope$sz_dir,function(x){x$idx}))
            ds_sum <- sapply(model$hillslope$sz_dir,function(x){sum(x$frc)})
            ds_sum <- abs(ds_sum-1)<delta
            if(!all(ds_hsu %in% all_hsu)){
                stop("Saturated Zone flow resistirbution is not valid: unexpected recieving HSUs")
            }
            if(!all(ds_sum)){
                stop(paste("Saturated Zone flow resistirbution is not valid: Fractions do not sum to one for HSUs",paste(model$hillslope$id[!ds_sum],collapse=", ")))
            }
            
            
            ## fcheck <- function(x){
            ##     all(x$idx %in% all_hsu) & (abs(sum(x$frc)-1) < delta)
            ## }
            ## idx <- sapply(model$hillslope$sz_dir,fcheck)
            ## if( any(!idx) ){
            ##     stop(paste("Saturated flow redistribution is not valid for HSUs:",
            ##                paste(model$hillslope$id[!idx],collapse=" ")))
            ## }
            ## idx <- sapply(model$hillslope$sf_dir,fcheck)
            ## if( any(!idx) ){
            ##     stop(paste("Surface flow redistribution is not valid for HSUs:",
            ##                paste(model$hillslope$id[!idx],collapse=" ")))
            ## }
            
            ## idx <- sapply(model$channel$flow_dir,function(x){is.null(x) | fcheck(x)})
            ## if( any(!idx) ){
            ##     stop(paste("Channel flow redistribution is not valid for HSUs:",
            ##                paste(model$channel$id[!idx],collapse=" ")))
            ## }
            
            ## specific checks on channel network connectivity - used in channel simulation
            chn_con <- lapply(model$channel$flow_dir,function(x){x$idx})

            n_chn_con <- sapply(chn_con,length) # number of connections
            is_outlet <- sapply(chn_con,is.null) # identify outlets
            is_in_network <- sapply(chn_con,function(x,y){all(x%in%y)},y=model$channel$id)
                                    
            if( any(n_chn_con>1) ){
                stop("Only channel HSUs routing to single channel HSUs are supported",
                     "\n",
                     "Channels HSUs with multiple downstream connections are ids: ",
                     paste(mdl$channel$id[n_chn_con>1],collapse=", "))
            }
            if( !all(is_in_network) ){
                ##do.call(c,chn_con) %in% model$channel$id) ){
                stop("Channels routing to non channel HSUs are ",
                     paste(mdl$channel$id[!is_in_network],collapse=", "),
                     "\n",
                     "Set next_id to NA to represent an outflow")
            }
            
            to_outlet <- is_outlet
            ## loop channels at top of network
            for(ii in setdiff(model$channel$id,do.call(c,chn_con))){
                ## set up a record of place in search down tree
                in_search <- rep(FALSE,length(model$channel$id))
                jj <- which(model$channel$id==ii)
                while( !in_search[jj] & # fails if loop
                       !to_outlet[jj] ){ # fails at outlet
                           in_search[jj] <- TRUE
                           jj <- which(model$channel$id==chn_con[[jj]])
                       }
                if(to_outlet[jj]){
                    to_outlet[in_search] <- TRUE
                }
            }
            if( any(!to_outlet) ){
                stop(paste("The following channels do not drain to an outlet:",
                           paste(model$channel$id[!to_outlet],collapse=" ")))
            }
            
            ## verbose printing of head and tail channels
            if(verbose){
                ## print out head channels
                message(paste("The head channels are:",
                              paste(setdiff(model$channel$id,chn_con),
                                    collapse=", "),
                              sep="\n"))
                ## print out tail channels
                message(paste("The channels with outfalls:",
                              paste(model$channel$id[is.na(chn_con)],
                                    collapse=", "),
                              sep="\n"))
            }

            ## TODO add checks to map
            
            
            ## if here we have passed all tests then return
            invisible( self )
            
        },
        
        ## check and add obsservations
        check_obs = function(obs){
            req_series <- private$info$data_series

            ## check types
            if(!is.xts(obs)){ stop("observations should be an xts object") }
            if(!is.vector(req_series) | !all(sapply(req_series,class)=='character') ){ stop("req_series should be a character vector") }
            
            ## check we have all the series needed
            if( !all( req_series %in% names(obs) ) ){
                stop("Missing input series:",setdiff( req_series , names(obs) ))
            }

            ## check constant time step
            tmp <- diff(as.numeric(index(obs)))
            if( !all( tmp == tmp[1] ) ){
                stop("Time steps in data are not unique")
            }
            
            ## check all values are finite
            if( !all(is.finite(obs[,req_series])) ){
                stop("There are non finite values in the required time series")
            }
        },
        digest_obs = function(obs){
            ## Assumes all checks passed
            private$time_series$obs_data <- as.matrix(obs)
            private$time_series$index <- index(obs)

            ## set the data series index in the model
            ## index is in C++ numbering starting from 0
            idx <- setNames((1:ncol(obs))-1,names(obs))
            for(tbl in names(private$model_description)){
                ## required properties
                prop <- private$model_description[[tbl]]

                for(ii in prop$name[prop$role == "data_series"]){
                    private$model[[tbl]][[ paste0(ii,"_index") ]]  <-  idx[ private$model[[tbl]][[ii]] ]
                }
            }
        },
        ## compute the simulation timestep
        comp_ts = function(sub_step=NULL){

            ## TODO move or replicate check in simulation call
            if( (!is.null(sub_step) & !is.numeric(sub_step)) | length(sub_step)>1 ){ stop("sub_step should be a single numeric value or NULL") }
            
            ## work out time steps for use in simulation
            ts <- list()
            ts$step <- diff(as.numeric(private$time_series$index[1:2])) # seconds
            if(is.null(sub_step)){sub_step <- ts$step}
            ts$n_sub_step <- max(1,floor(ts$step/sub_step)) # dimensionless
            ts$sub_step <- ts$step / ts$n_sub_step
            private$info$ts <- ts
        },
        ## ###########################################
        ## Initialise the states
        init_hs = function(initial_recharge){
            ## TODO check initial recharge
                        
            hs_init_cpp(private$model$hillslope,
                        private$model$sqnc,
                        as.numeric(initial_recharge[1]))

            ##print("returning from init_hs")
            
        },
        ## ###############################
        ## function to perform simulations
        sim_hs = function(mass_check,keep_states,sub_step, use_R){
            
            ## compute time substep
            if( !is.null(sub_step) && !is.finite(sub_step[1]) ){
                stop("sub_step should be a single finite value")
            }
            ts <- private$comp_ts(sub_step)
            
            ## Logical if states to be kept and store
            keep_states <- private$time_series$index %in% keep_states
            if(any(keep_states)){
                private$time_series$state_record <- rep(list(as.data.frame(NULL)),length(private$time_series$index))
            }else{
                private$time_series$state_record <- NULL
            }

            ## Initialise the mass error store
            if(mass_check){
                ## set to as.numeric(NA) so type picked up by Rcpp
                private$time_series$mass_errors <- matrix(as.numeric(NA),nrow(private$time_series$obs),6)
                colnames(private$time_series$mass_errors) <-
                    c("initial_state","final_state","p","e_t",
                      "channel_inflow","error")
            }else{
                ## initialise so can pass correctly
                private$time_series$mass_errors <- matrix(-Inf,1,1)
            }
            
            ## make local copy of channel_inflow
            private$time_series$channel_inflow <- matrix(as.numeric(NA),
                                                         nrow(private$time_series$obs),
                                                         length(private$model$channel$id))
            colnames(private$time_series$channel_inflow) <- private$model$channel$id
                        
            
            
            ## use the Cpp version
            hs_sim_cpp(private$model$hillslope,
                       private$model$channel,
                       private$model$sqnc,
                       private$time_series$obs,
                       ts,
                       private$time_series$channel_inflow,
                       mass_check,
                       private$time_series$mass_errors,
                       keep_states,
                       private$time_series$state_record)
            
            ## tidy up dummy input
            if( !mass_check ){
                private$time_series$mass_errors <- NULL
            }
            
        },
        ## convert a data frame to a storage list
        extract_states = function(obj,type=names(private$model_description)){
            type <- match.arg(type)

            stt <- private$model_description[[type]]
            stt <- c("id",stt$name[stt$role=="state"])
            out <- as.data.frame( obj[stt], stringsAsFactors=FALSE )
            return(out)
        },
        ## #############################
        init_ch = function(){
            
            channel <- private$model$channel
            gauge <- private$model$gauge
            point_inflow <- private$model$point_inflow
            
            ## check each channel has only one down stream neighbour
            ## Done it check_model

            ## check channel HSU id numbers are 1,2,3,....
            
            if( !all(channel$id %in% 1:length(channel$id)) ){
                stop("Channel id should be numbered 1,2,.. with no gaps")
            }
            
            ## get the channels downstream of each id
            chn_con <- sapply(channel$flow_dir,
                              function(x){if(is.null(x)){-99}else{x$idx}})
            chn_con[channel$id] <- unname(chn_con)
            
            ## compute the time to travel down each reach
            
            reach_time <- unname( channel$length / channel$v_ch_value )
            reach_time[channel$id] <- unname(reach_time)


            linear_time <- setNames(rep(list(NULL),length(gauge$name)),
                                    gauge$name)
            
            ## Loop gauges
            for(rw in 1:length(gauge$name)){
                time_to_head <- rep(NA,length(channel$id))
                ## add gaguge reach is in
                ii <- gauge$id[rw]
                time_to_head[ii] <- reach_time[ii]*gauge$fraction[rw]
                ## get upstream reaches
                idx <- which(chn_con==ii)
                ## loop upstream
                while(length(idx)>0){
                    idx_list <- list()
                    cnt <- 1
                    for(ii in idx){
                        time_to_head[ii] <- reach_time[ii] + time_to_head[ chn_con[ii] ]
                        idx_list[[cnt]] <- which(chn_con==ii)
                        cnt <- cnt+1
                    }
                    idx <- do.call(c,idx_list)
                }
                ## initialise gauge timeing object
                tmp <- list(diffuse=list(),
                            point=list())

                ## work out for diffuse inputs
                for(ii in which(is.finite(time_to_head))){
                    tmp$diffuse[[paste(ii)]] <- list(head_to_gauge=time_to_head[ii],
                                                     reach_time = reach_time[ii])
                }

                ## work out for points
                if(length(point_inflow$name)>0){
                    for(ii in 1:length(point_inflow$name)){
                        jj <- point_inflow$id[ii]
                        if( is.finite( time_to_head[ jj ] ) ){
                            delta <- time_to_head[jj]* point_inflow$fraction[ii]
                            tmp$point[[ point_inflow$name[ii] ]] <- list(
                                head_to_gauge = time_to_head[jj] - delta,
                                reach_time = 0)
                        }
                    }
                }
                linear_time[[gauge$name[rw]]] <- tmp
            }
            
            private$model$linear_channel <- linear_time
        },
        sim_ch = function(){
            ## initialise the output
            out <- matrix(NA,length(private$time_series$index),
                          length(private$model$linear_channel))
            colnames(out) <- names(private$model$linear_channel)
            
            ## function to make polynonial representing tiem delay histogram
            fpoly <- function(x){
                if( x$reach_time == 0 ){
                    ## point input
                    ms <- floor(x$head_to_gauge/private$info$ts$step)+1
                    ply <- rep(0,ms)
                    ply[ms] <- 1
                }else{
                    ms <- ceiling(x$head_to_gauge/private$info$ts$step)
                    ply <- (0:ms)*private$info$ts$step
                    ply[ply<=x$head_to_gauge - x$reach_time] <- x$head_to_gauge - x$reach_time
                    ply[ply>x$head_to_gauge] <- x$head_to_gauge
                    ply <- diff(ply)
                    ply <- ply/x$reach_time 
                }
                return(ply)
            }
    
            ## Loop gauges
            
            for(id in names(private$model$linear_channel)){

                ## initialise the point - set to 0
                out[,id] <- 0
                
                
                ## loop channel+diffuse upstream
                for(iid in names(private$model$linear_channel[[id]]$diffuse)){
                    ## get time object
                    tt <- private$model$linear_channel[[id]]$diffuse[[iid]]
                    ## compute polynomial
                    ply <- fpoly(tt)
                    npad <- length(ply)-1
                    ## compute input
                    x <- private$time_series$channel_inflow[,iid]
                    ## add diffuse inputs to x
                    nm <- private$model$diffuse_inflow$name[private$model$diffuse_inflow$id==id]
                    x <- x + rowSums(private$time_series$obs[,nm])

                    ## add initial padding to input
                    x <- c(rep(x[1],npad),x)
                    ## apply polynomial
                    q <- filter(x,ply,method="conv",sides=1)
                    if(npad>0){q <- q[-(1:npad)]}
                    out[,id] <- out[,id] + q
                }
                
                ## loop point inputs upstream
                for(iid in names(private$model$linear_channel[[id]]$point)){
                    ## get time object
                    tt <- private$model$linear_channel[[id]]$diffuse[[iid]]
                    ## compute polynomial
                    ply <- fply(tt)
                    npad <- length(ply)-1
                    ## compute input
                    x <- private$time_series$obs[,iid]
                    ##TODO add diffuse inputs to x
                    x <- c(rep(x[1],npad),x)
                    ## apply polynomial
                    q <- filter(x,ply,method="conv",sides=1)
                    if(npad>0){q <- q[-(1:npad)]}
                    out[,id] <- out[,id] + q
                }

            }

            private$time_series$gauge_flow <- out
        }
    )
    )

    
    
