#include "sf.h"

// solve 
sfc::sfc(){ }
// fq compute the outflow given the other variables
double sfc::fq(double const &s, double const &qin, double const &r){ return(-999.9);}
// fs computes  steady state storage given the outflow and inflow
double sfc::fs(double const &q, double const &qin){return(-999.9);}
// solution for a linear tank
double sfc::solve_linear_tank(double const &s0, double const &qin, double const &vin, double const &Dt, double const &eta, double const &kappa){
  double smax = s0 + Dt*qin - vin;
  double sc = eta*qin/kappa;
  double shat;
  if ( smax <= sc ){ shat =std::max(0.0,smax) ; }
  else{
    shat =  (s0 + Dt*(qin/(1-eta)) - vin ) / (1+(Dt*kappa/(1-eta))) ;
  }
  return( shat );
}
void sfc::update(double &s, double &q, double const &qin, double const &vin,
		 double const &Dt, double const &vtol, int const &max_it){
  
  double sfmax = s + Dt*qin - vin;
  double rin = vin / Dt;
  std::pair<double,double> lbnd(0.0, 999.9);
  double qq = fq(lbnd.first,qin,rin);
  lbnd.second = sfmax - Dt*qq - lbnd.first;
  
  std::pair<double,double> ubnd(sfmax, 999.9);
  qq = fq(ubnd.first,qin,rin);
  ubnd.second = sfmax - Dt*qq - ubnd.first;
  
  int it = 0;
  while( (it <= max_it) and ( (ubnd.first - lbnd.first)>vtol ) ){ //( (bnd.second - bnd.first)>vtol ) ){
    //z = (bnd.first+bnd.second)/2.0;
    //z = (lbnd.first+ubnd.first)/2.0;
    double iW = ubnd.second / (ubnd.second-lbnd.second);
    iW = std::max(0.001,std::min(iW,0.999));
    double z = (iW*lbnd.first) + (1.0-iW)*ubnd.first;
    qq = fq(z,qin,rin);
    double Sw = sfmax - Dt*qq - z;
    if( Sw <= 0 ){ //bnd.second= z; } else { bnd.first=z; }
      ubnd.first = z;
      ubnd.second = Sw;
    }else{
      lbnd.first = z;
      lbnd.second = Sw;
    }
    it += 1;
  }
  double z = lbnd.first;
  //z = bnd.first;
  q = qin + (s - vin - z)/Dt;
  s = z;
};
    

// constant celerity, diffusivity with raf
sfc_cnst::sfc_cnst(std::vector<double> const &param, std::vector<double> const &properties){
  double const& Dx(properties[2]);
  kappa = param[0]/Dx; // celerity divided by length to get q from storage
  eta = 0.5 - (param[1] / (param[0]*Dx)); // could retrun negative eta....
  s_raf = param[2]; // raf storage
  t_raf = param[3]; // raf time constant
  q_raf = s_raf/t_raf; // raf max flow
}
double sfc_cnst::fq(double const &s, double const &qin, double const &r){
  double qq(-999.9);
  if( s <= s_raf ){
    qq = s / t_raf;
  }else{
    qq = ( kappa*(s-s_raf) - (eta*std::max(qin-q_raf,0.0)) ) / (1-eta); // flow from outside raf
    qq = std::max(0.0,qq); // ensure positive
    qq += q_raf; // add raf outfloe
  }
  return( qq );
}
double sfc_cnst::fs(double const &q, double const &qin){
  double ss(-999.9);
  if( q > q_raf ){
    ss = ( (1-eta)*(q-q_raf) + eta*(std::max(0.0,qin-q_raf)) ) / kappa;
    ss += s_raf;
  }else{
    ss = q*t_raf;
  }
  return(ss);
}

// Kinematic with raf
// Assumes shallow water so wetted perimeter ~ width
sfc_kin::sfc_kin(std::vector<double> const &param, std::vector<double> const &properties){
  double const &Dx(properties[2]), &width(properties[1]), &grd(properties[3]);
  double const &n(param[0]);
  kappa = Dx;
  omega = std::pow(grd,0.5) / (n * std::pow(width,(2.0/3.0)));
  s_raf = param[1]; // raf storage
  t_raf = param[2]; // raf time constant
  q_raf = s_raf/t_raf; // raf max flow
  
}
double sfc_kin::fq(double const &s, double const &qin, double const &r){
  double qq(-999.9);
  if( s <= s_raf ){
    qq = s / t_raf;
  }else{
    qq = omega * std::pow( (s-s_raf)/kappa, (5.0/3.0) );
    qq = std::max( 0.0, 2*qq - std::max(qin-q_raf,0.0) );
    qq += q_raf; // add raf outfloe
  }
  return( qq );
}

double sfc_kin::fs(double const &q, double const &qin){
  double ss(-999.9);
  if( q > q_raf ){
    ss = kappa * std::pow( (q+qin)/(2*omega), 3.0/5.0 ) ;
    ss += s_raf;
  }else{
    ss = q*t_raf;
  }
  return( ss );
}


// compound channel
sfc_comp::sfc_comp(std::vector<double> const &param, std::vector<double> const &properties){
  double const& Dx(properties[2]);
  kappa_1 = param[0]/Dx; // velocity divided by length to get q from storage for lower part of channel
  eta_1 = 0.5 - (param[1] / (param[0]*Dx));  // Dispersion property for lower part of channel
  s_1 = param[2]; // max stoage in lower part of channel
  kappa_2 = param[3]/Dx; // velocity divided by length to get q from storage for upper part of channel
  eta_2 = 0.5 - (param[4] / (param[3]*Dx));  // Dispersion property for upper part of channel
  q_1_max = s_1*kappa_1; // max inflow to lower part of channel
 
  Rcpp::Rcout << eta_1 << " " << kappa_1 << " " << s_1 << " " << q_1_max << std::endl;
  Rcpp::Rcout << eta_2 << " " << kappa_2 << std::endl;
  
}
double sfc_comp::fq(double const &s, double const &qin, double const &r){
  //double qhat = kappa_1*std::min(s,s_1) + kappa_2*std::max(s-s_1,0.0);
  //double qq = std::max(0.0, (qhat - eta_1*qin) / (1-eta_1) );
  
  
  double q_1_max = std::max(0.0, s_1*kappa_1 + (1-eta_1)*r);
  double q_1 = std::min(qin,q_1_max);
  double q_2 = std::max(0.0,qin-q_1_max);
  
  double qq = std::max(0.0, (std::min(s,s_1)*kappa_1 - eta_1*q_1) / (1-eta_1) )
    + std::max(0.0, (std::max(s-s_1,0.0)*kappa_2 - eta_2*q_2) / (1-eta_2)) ;
  return( qq );
 
}
double sfc_comp::fs(double const &q, double const &qin){
  double qq = eta_1*qin + (1-eta_1)*q;
  double ss;
  if( qq > q_1_max ){
    ss = s_1 + (qq-q_1_max)/kappa_2;
  }else{
    ss = qq/kappa_1;
  }
  // bool flg(false);
  //   if( (q==0.0) and (qin > 0.0) ){
  //   flg = true;
  // }
  
  // double q_1 = std::min(qin,q_1_max) ; //std::max(0.0,std::min(qin,q_1_max));
  // double q_2 = std::max(0.0,qin-q_1_max);
  // double qq = std::max(0.0, (q_1_max - eta_1*q_1)/(1-eta_1)); // outflow at stroage at s_1
  // // if( flg ){
  // //   Rcpp::Rcout << q << " " << qin << " " << qq << " " << q_1 << " " << q_2 << " " << s_1 << std::endl;
  // // }
  // double ss(-999.9);
  // if( qq >= q ){ // then storage between 0 & s_1
  //   //    if( flg ){ Rcpp::Rcout <<  "In stage 1" << " " << eta_1 << std::endl; }
  //   ss = ( (1-eta_1)*q + eta_1*q_1 ) / kappa_1;
  // }else{
  //   qq = q-qq; // flow from upper part of channel
  //   // if( flg ){ Rcpp::Rcout <<  "In stage 2" << " " << qq << std::endl; }
  //   ss = ( (1-eta_2)*qq + eta_2*q_2 ) / kappa_2;
  //   ss += s_1;

  // }
  return(ss);
  
}
// void sfc_comp::update(double &s, double &q, double const &qin, double const &vin,
// 		      double const &Dt, double const &vtol, int const &max_it){

//   // split inflow
//   double q1 = std::min(qin, q_1_max);
//   double q2 = std::max(qin-q1, 0.0);
//   double s1 = std::min(s,s_1);
//   double s2 = std::max(s-s1, 0.0);

//   double shat1 =  solve_linear_tank(s1, q1, vin, Dt, eta_1, kappa_1);
//   double shat2 =  solve_linear_tank(s2, q2, 0.0, Dt, eta_2, kappa_2);

//   q = ( (s + Dt*qin -vin) - shat1 - shat2 ) / Dt;
//   s = shat1 + shat2;
// }

//   double smax = s + Dt*qin - vin;
//   // see which side of s_1 we are
//   double shat = smax - Dt*(kappa_1*s_1 - eta_1*q_1)/(1-eta_1);
//   if( shat > s_1 ){
//     // then into top part of the channel
    
    
  


  
//   bool flg(false);
//   // try putting everying into lower part of channel
//   double shat =  solve_linear_tank(s, qin, vin, Dt, eta_1, kappa_1);
//   double shat0 = shat;
//   int path(0);
  
//   if( shat > s_1 ){  // then in the top part of the channel
//     path +=1;
//     flg = true;
//     //Rcpp::Rcout << "In inner part" << std::endl;
//     //Rcpp::Rcout << "shat at start is " << shat << std::endl;
//     //Rcpp::Rcout << "s_1 is " << s_1 << std::endl;
//     double qhat = (s_1 - s + vin) / Dt;
//     //Rcpp::Rcout << "In inner part " << qhat << " " << kappa_1*s_1/eta_1 << std::endl;
//     if( kappa_1*s_1/eta_1 > qhat ){
//       qhat = ( ( (1-eta_1 + kappa_1*Dt)*s_1 ) - (1-eta_1)*(s-vin) ) / Dt;
//       //qhat = ( (1+(Dt*kappa_1/(1-eta_1)))*s_1 - s + vin ) /(Dt/(1-eta_1));
//       //Rcpp::Rcout << "reset qhat" << std::endl;
//       path +=10;
//     }
//     if( qhat > 0 ){
//       shat = 0;
//       path +=1;
//     }
//     else{
//       qhat = 0.0;
//       shat = s - vin - (1 + (Dt*kappa_1/(1-eta_1)))*s_1;
//       //Rcpp::Rcout << "reset shat" << std::endl;
//       path +=5;
//     }
//     // solve upper linear tank
//     //Rcpp::Rcout << "Solve upper tank " << shat << " " << qin << " " << qhat << std::endl;
//     double z =  solve_linear_tank(shat, qin-qhat, 0.0, Dt, eta_2, kappa_2);
//     shat = s_1 + z;
//     //Rcpp::Rcout << "shat at end of inner part is " << shat << std::endl;
//   }
//   q = ( (s + Dt*qin -vin) - shat ) / Dt;
//   // if(flg){
//   //   Rcpp::Rcout << "shat at end of outer part is " << shat << std::endl;
//   // }
//   if( std::abs(shat0-shat) > 0.1 ){
//     Rcpp::Rcout << "shat not equal " << s << " " << s_1 << " " << shat0 << " " << shat << " " << path << std::endl;
//   }
  
//   s = shat;
// };
